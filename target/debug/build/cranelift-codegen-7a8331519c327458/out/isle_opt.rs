// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/prelude.isle
// - src/prelude_opt.isle
// - src/opts/algebraic.isle
// - src/opts/icmp.isle
// - src/opts/cprop.isle
// - /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle

use super::*; // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self) -> Unit;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> u32;
    fn u32_lteq(&mut self, arg0: u32, arg1: u32) -> Option<Unit>;
    fn u8_lteq(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn simm32(&mut self, arg0: Imm64) -> Option<u32>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn u8_as_u32(&mut self, arg0: u8) -> u32;
    fn u8_as_u64(&mut self, arg0: u8) -> u64;
    fn u16_as_u64(&mut self, arg0: u16) -> u64;
    fn u32_as_u64(&mut self, arg0: u32) -> u64;
    fn i64_as_u64(&mut self, arg0: i64) -> u64;
    fn i64_neg(&mut self, arg0: i64) -> i64;
    fn u128_as_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u64_as_u32(&mut self, arg0: u64) -> Option<u32>;
    fn u64_as_i32(&mut self, arg0: u64) -> i32;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn s32_add_fallible(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sdiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_udiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_shl(&mut self, arg0: u64, arg1: u64) -> u64;
    fn imm64_shl(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_ushr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_sshr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn u64_not(&mut self, arg0: u64) -> u64;
    fn u64_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_le(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_lt(&mut self, arg0: u64, arg1: u64) -> bool;
    fn i64_sextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> i64;
    fn u64_uextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> u64;
    fn imm64_icmp(&mut self, arg0: Type, arg1: &IntCC, arg2: Imm64, arg3: Imm64) -> Imm64;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_is_odd(&mut self, arg0: u64) -> bool;
    fn ty_umin(&mut self, arg0: Type) -> u64;
    fn ty_umax(&mut self, arg0: Type) -> u64;
    fn ty_smin(&mut self, arg0: Type) -> u64;
    fn ty_smax(&mut self, arg0: Type) -> u64;
    fn ty_bits(&mut self, arg0: Type) -> u8;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn mem_flags_trusted(&mut self) -> MemFlags;
    fn intcc_reverse(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_inverse(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_reverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_inverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_unordered(&mut self, arg0: &FloatCC) -> bool;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_addr64(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64_power_of_two(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Imm64;
    fn imm64_masked(&mut self, arg0: Type, arg1: u64) -> Imm64;
    fn u32_from_ieee32(&mut self, arg0: Ieee32) -> u32;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_int_lane(&mut self, arg0: Type) -> Option<u32>;
    fn dynamic_fp_lane(&mut self, arg0: Type) -> Option<u32>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_u32(&mut self, arg0: Offset32) -> u32;
    fn u32_to_offset32(&mut self, arg0: u32) -> Offset32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self) -> TrapCode;
    fn trap_code_integer_overflow(&mut self) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self) -> TrapCode;
    fn range(&mut self, arg0: usize, arg1: usize) -> Range;
    fn range_view(&mut self, arg0: Range) -> RangeView;
    type inst_data_etor_iter: ContextIter<Context = Self, Output = (Type, InstructionData)>;
    fn inst_data_etor(&mut self, arg0: Value) -> Self::inst_data_etor_iter;
    fn make_inst_ctor(&mut self, arg0: Type, arg1: &InstructionData) -> Value;
    fn value_array_2_ctor(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn value_array_3_ctor(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn remat(&mut self, arg0: Value) -> Value;
    fn subsume(&mut self, arg0: Value) -> Value;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn unpack_block_array_2(&mut self, arg0: &BlockArray2) -> (BlockCall, BlockCall);
    fn pack_block_array_2(&mut self, arg0: BlockCall, arg1: BlockCall) -> BlockArray2;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
}

pub struct ContextIterWrapper<Item, I: Iterator<Item = Item>, C: Context> {
    iter: I,
    _ctx: PhantomData<C>,
}
impl<Item, I: Iterator<Item = Item>, C: Context> From<I> for ContextIterWrapper<Item, I, C> {
    fn from(iter: I) -> Self {
        Self {
            iter,
            _ctx: PhantomData,
        }
    }
}
impl<Item, I: Iterator<Item = Item>, C: Context> ContextIter for ContextIterWrapper<Item, I, C> {
    type Context = C;
    type Output = Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
}

// Generated as internal constructor for term eq.
pub fn constructor_eq<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::Equal, arg1, arg2);
    // Rule at src/prelude_opt.isle line 20.
    return v4;
}

// Generated as internal constructor for term ne.
pub fn constructor_ne<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::NotEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 21.
    return v4;
}

// Generated as internal constructor for term ult.
pub fn constructor_ult<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 22.
    return v4;
}

// Generated as internal constructor for term ule.
pub fn constructor_ule<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 23.
    return v4;
}

// Generated as internal constructor for term ugt.
pub fn constructor_ugt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 24.
    return v4;
}

// Generated as internal constructor for term uge.
pub fn constructor_uge<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 25.
    return v4;
}

// Generated as internal constructor for term slt.
pub fn constructor_slt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 26.
    return v4;
}

// Generated as internal constructor for term sle.
pub fn constructor_sle<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 27.
    return v4;
}

// Generated as internal constructor for term sgt.
pub fn constructor_sgt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 28.
    return v4;
}

// Generated as internal constructor for term sge.
pub fn constructor_sge<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 29.
    return v4;
}

// Generated as internal constructor for term simplify.
pub fn constructor_simplify<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> impl ContextIter<Context = C, Output = Value> {
    let mut returns = ConstructorVec::new();
    let v1 = C::inst_data_etor(ctx, arg0);
    let mut v1 = v1;
    while let Some(v2) = v1.next(ctx) {
        match &v2.1 {
            &InstructionData::Binary {
                opcode: ref v15,
                args: ref v16,
            } => {
                match v15 {
                    &Opcode::Iadd => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v28 = C::inst_data_etor(ctx, v17.0);
                        let mut v28 = v28;
                        while let Some(v29) = v28.next(ctx) {
                            match &v29.1 {
                                &InstructionData::Binary {
                                    opcode: ref v70,
                                    args: ref v71,
                                } => {
                                    match v70 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v29.0 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v2.0 == v21.0 {
                                                                let v72 = C::unpack_value_array_2(
                                                                    ctx, v71,
                                                                );
                                                                let v82 =
                                                                    C::inst_data_etor(ctx, v72.1);
                                                                let mut v82 = v82;
                                                                while let Some(v83) = v82.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v86,
                                                                        imm: v87,
                                                                    } = &v83.1 {
                                                                        if let &Opcode::Iconst = v86 {
                                                                            if v2.0 == v83.0 {
                                                                                let v352 = constructor_iadd(ctx, v2.0, v72.1, v17.1);
                                                                                let v353 = constructor_iadd(ctx, v2.0, v72.0, v352);
                                                                                // Rule at src/opts/cprop.isle line 122.
                                                                                returns.push(v353);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v29.0 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v2.0 == v21.0 {
                                                                let v72 = C::unpack_value_array_2(
                                                                    ctx, v71,
                                                                );
                                                                let v82 =
                                                                    C::inst_data_etor(ctx, v72.1);
                                                                let mut v82 = v82;
                                                                while let Some(v83) = v82.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v86,
                                                                        imm: v87,
                                                                    } = &v83.1 {
                                                                        if let &Opcode::Iconst = v86 {
                                                                            if v2.0 == v83.0 {
                                                                                let v26 = C::u64_from_imm64(ctx, v25);
                                                                                let v88 = C::u64_from_imm64(ctx, v87);
                                                                                let v365 = C::u64_sub(ctx, v26, v88);
                                                                                let v366 = C::imm64_masked(ctx, v2.0, v365);
                                                                                let v367 = constructor_iconst(ctx, v2.0, v366);
                                                                                let v369 = constructor_iadd(ctx, v2.0, v72.0, v367);
                                                                                // Rule at src/opts/cprop.isle line 144.
                                                                                returns.push(v369);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                let v118 =
                                                                    C::inst_data_etor(ctx, v72.0);
                                                                let mut v118 = v118;
                                                                while let Some(v119) =
                                                                    v118.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v358,
                                                                        imm: v359,
                                                                    } = &v119.1 {
                                                                        if let &Opcode::Iconst = v358 {
                                                                            if v2.0 == v119.0 {
                                                                                let v360 = C::u64_from_imm64(ctx, v359);
                                                                                let v26 = C::u64_from_imm64(ctx, v25);
                                                                                let v370 = C::u64_add(ctx, v360, v26);
                                                                                let v371 = C::imm64_masked(ctx, v2.0, v370);
                                                                                let v372 = constructor_iconst(ctx, v2.0, v371);
                                                                                let v373 = constructor_isub(ctx, v2.0, v372, v72.1);
                                                                                // Rule at src/opts/cprop.isle line 148.
                                                                                returns.push(v373);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v32,
                                    imm: v33,
                                } => {
                                    if let &Opcode::Iconst = v32 {
                                        if v2.0 == v29.0 {
                                            let v34 = C::u64_from_imm64(ctx, v33);
                                            if v34 == 0x0 {
                                                let v35 = C::subsume(ctx, v17.1);
                                                // Rule at src/opts/algebraic.isle line 20.
                                                returns.push(v35);
                                            }
                                            let v343 = constructor_iadd(ctx, v2.0, v17.1, v17.0);
                                            // Rule at src/opts/cprop.isle line 91.
                                            returns.push(v343);
                                        }
                                        let v46 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v47) = v46 {
                                            if v29.0 == v47 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v21.0 == v29.0 {
                                                                let v34 =
                                                                    C::u64_from_imm64(ctx, v33);
                                                                let v26 =
                                                                    C::u64_from_imm64(ctx, v25);
                                                                let v279 =
                                                                    C::u64_add(ctx, v34, v26);
                                                                let v280 =
                                                                    C::imm64_masked(ctx, v47, v279);
                                                                let v281 = constructor_iconst(
                                                                    ctx, v47, v280,
                                                                );
                                                                let v282 = C::subsume(ctx, v281);
                                                                // Rule at src/opts/cprop.isle line 3.
                                                                returns.push(v282);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v138 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 296.
                                        returns.push(v138);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x0 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 16.
                                            returns.push(v27);
                                        }
                                    }
                                    let v138 = C::remat(ctx, arg0);
                                    // Rule at src/opts/algebraic.isle line 298.
                                    returns.push(v138);
                                }
                            }
                        }
                    }
                    &Opcode::Isub => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v28 = C::inst_data_etor(ctx, v17.0);
                        let mut v28 = v28;
                        while let Some(v29) = v28.next(ctx) {
                            match &v29.1 {
                                &InstructionData::Binary {
                                    opcode: ref v70,
                                    args: ref v71,
                                } => {
                                    match v70 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v29.0 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v2.0 == v21.0 {
                                                                let v72 = C::unpack_value_array_2(
                                                                    ctx, v71,
                                                                );
                                                                let v82 =
                                                                    C::inst_data_etor(ctx, v72.1);
                                                                let mut v82 = v82;
                                                                while let Some(v83) = v82.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v86,
                                                                        imm: v87,
                                                                    } = &v83.1 {
                                                                        if let &Opcode::Iconst = v86 {
                                                                            if v2.0 == v83.0 {
                                                                                let v26 = C::u64_from_imm64(ctx, v25);
                                                                                let v88 = C::u64_from_imm64(ctx, v87);
                                                                                let v365 = C::u64_sub(ctx, v26, v88);
                                                                                let v366 = C::imm64_masked(ctx, v2.0, v365);
                                                                                let v367 = constructor_iconst(ctx, v2.0, v366);
                                                                                let v368 = constructor_isub(ctx, v2.0, v72.0, v367);
                                                                                // Rule at src/opts/cprop.isle line 140.
                                                                                returns.push(v368);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v29.0 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v2.0 == v21.0 {
                                                                let v72 = C::unpack_value_array_2(
                                                                    ctx, v71,
                                                                );
                                                                let v82 =
                                                                    C::inst_data_etor(ctx, v72.1);
                                                                let mut v82 = v82;
                                                                while let Some(v83) = v82.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v86,
                                                                        imm: v87,
                                                                    } = &v83.1 {
                                                                        if let &Opcode::Iconst = v86 {
                                                                            if v2.0 == v83.0 {
                                                                                let v88 = C::u64_from_imm64(ctx, v87);
                                                                                let v26 = C::u64_from_imm64(ctx, v25);
                                                                                let v354 = C::u64_add(ctx, v88, v26);
                                                                                let v355 = C::imm64_masked(ctx, v2.0, v354);
                                                                                let v356 = constructor_iconst(ctx, v2.0, v355);
                                                                                let v357 = constructor_isub(ctx, v2.0, v72.0, v356);
                                                                                // Rule at src/opts/cprop.isle line 132.
                                                                                returns.push(v357);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                let v118 =
                                                                    C::inst_data_etor(ctx, v72.0);
                                                                let mut v118 = v118;
                                                                while let Some(v119) =
                                                                    v118.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v358,
                                                                        imm: v359,
                                                                    } = &v119.1 {
                                                                        if let &Opcode::Iconst = v358 {
                                                                            if v2.0 == v119.0 {
                                                                                let v360 = C::u64_from_imm64(ctx, v359);
                                                                                let v26 = C::u64_from_imm64(ctx, v25);
                                                                                let v361 = C::u64_sub(ctx, v360, v26);
                                                                                let v362 = C::imm64_masked(ctx, v2.0, v361);
                                                                                let v363 = constructor_iconst(ctx, v2.0, v362);
                                                                                let v364 = constructor_isub(ctx, v2.0, v363, v72.1);
                                                                                // Rule at src/opts/cprop.isle line 136.
                                                                                returns.push(v364);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v32,
                                    imm: v33,
                                } => {
                                    if let &Opcode::Iconst = v32 {
                                        if v2.0 == v29.0 {
                                            let v34 = C::u64_from_imm64(ctx, v33);
                                            if v34 == 0x0 {
                                                let v36 = constructor_ineg(ctx, v2.0, v17.1);
                                                // Rule at src/opts/algebraic.isle line 30.
                                                returns.push(v36);
                                            }
                                            let v344 = constructor_isub(ctx, v2.0, v17.1, v17.0);
                                            let v345 = constructor_ineg(ctx, v2.0, v344);
                                            // Rule at src/opts/cprop.isle line 96.
                                            returns.push(v345);
                                        }
                                        let v46 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v47) = v46 {
                                            if v29.0 == v47 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v21.0 == v29.0 {
                                                                let v34 =
                                                                    C::u64_from_imm64(ctx, v33);
                                                                let v26 =
                                                                    C::u64_from_imm64(ctx, v25);
                                                                let v283 =
                                                                    C::u64_sub(ctx, v34, v26);
                                                                let v284 =
                                                                    C::imm64_masked(ctx, v47, v283);
                                                                let v285 = constructor_iconst(
                                                                    ctx, v47, v284,
                                                                );
                                                                let v286 = C::subsume(ctx, v285);
                                                                // Rule at src/opts/cprop.isle line 9.
                                                                returns.push(v286);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v138 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 300.
                                        returns.push(v138);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x0 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 25.
                                            returns.push(v27);
                                        }
                                    }
                                    let v138 = C::remat(ctx, arg0);
                                    // Rule at src/opts/algebraic.isle line 302.
                                    returns.push(v138);
                                }
                            }
                        }
                        if v17.0 == v17.1 {
                            let v46 = C::fits_in_64(ctx, v2.0);
                            if let Some(v47) = v46 {
                                let v48 = C::ty_int(ctx, v47);
                                if let Some(v49) = v48 {
                                    let v51 = C::imm64(ctx, 0x0);
                                    let v52 = constructor_iconst(ctx, v49, v51);
                                    let v53 = C::subsume(ctx, v52);
                                    // Rule at src/opts/algebraic.isle line 51.
                                    returns.push(v53);
                                }
                            }
                        }
                    }
                    &Opcode::Imul => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v28 = C::inst_data_etor(ctx, v17.0);
                        let mut v28 = v28;
                        while let Some(v29) = v28.next(ctx) {
                            match &v29.1 {
                                &InstructionData::Binary {
                                    opcode: ref v70,
                                    args: ref v71,
                                } => {
                                    if let &Opcode::Imul = v70 {
                                        if v2.0 == v29.0 {
                                            let v20 = C::inst_data_etor(ctx, v17.1);
                                            let mut v20 = v20;
                                            while let Some(v21) = v20.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v24,
                                                    imm: v25,
                                                } = &v21.1
                                                {
                                                    if let &Opcode::Iconst = v24 {
                                                        if v2.0 == v21.0 {
                                                            let v72 =
                                                                C::unpack_value_array_2(ctx, v71);
                                                            let v82 = C::inst_data_etor(ctx, v72.1);
                                                            let mut v82 = v82;
                                                            while let Some(v83) = v82.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v86,
                                                                    imm: v87,
                                                                } = &v83.1 {
                                                                    if let &Opcode::Iconst = v86 {
                                                                        if v2.0 == v83.0 {
                                                                            let v374 = constructor_imul(ctx, v2.0, v72.1, v17.1);
                                                                            let v375 = constructor_imul(ctx, v2.0, v72.0, v374);
                                                                            // Rule at src/opts/cprop.isle line 153.
                                                                            returns.push(v375);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v38,
                                    arg: v39,
                                } => {
                                    if let &Opcode::Ineg = v38 {
                                        if v2.0 == v29.0 {
                                            let v20 = C::inst_data_etor(ctx, v17.1);
                                            let mut v20 = v20;
                                            while let Some(v21) = v20.next(ctx) {
                                                if let &InstructionData::Unary {
                                                    opcode: ref v40,
                                                    arg: v41,
                                                } = &v21.1
                                                {
                                                    if let &Opcode::Ineg = v40 {
                                                        if v2.0 == v21.0 {
                                                            let v42 = constructor_imul(
                                                                ctx, v2.0, v39, v41,
                                                            );
                                                            let v43 = C::subsume(ctx, v42);
                                                            // Rule at src/opts/algebraic.isle line 39.
                                                            returns.push(v43);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v32,
                                    imm: v33,
                                } => {
                                    if let &Opcode::Iconst = v32 {
                                        if v2.0 == v29.0 {
                                            let v34 = C::u64_from_imm64(ctx, v33);
                                            match v34 {
                                                0x0 => {
                                                    let v27 = C::subsume(ctx, v17.0);
                                                    // Rule at src/opts/algebraic.isle line 68.
                                                    returns.push(v27);
                                                }
                                                0x1 => {
                                                    let v35 = C::subsume(ctx, v17.1);
                                                    // Rule at src/opts/algebraic.isle line 58.
                                                    returns.push(v35);
                                                }
                                                _ => {}
                                            }
                                            let v56 = C::i64_sextend_imm64(ctx, v2.0, v33);
                                            if v56 == -0x1 {
                                                let v36 = constructor_ineg(ctx, v2.0, v17.1);
                                                // Rule at src/opts/algebraic.isle line 77.
                                                returns.push(v36);
                                            }
                                            let v346 = constructor_imul(ctx, v2.0, v17.1, v17.0);
                                            // Rule at src/opts/cprop.isle line 99.
                                            returns.push(v346);
                                        }
                                        let v46 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v47) = v46 {
                                            if v29.0 == v47 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v21.0 == v29.0 {
                                                                let v34 =
                                                                    C::u64_from_imm64(ctx, v33);
                                                                let v26 =
                                                                    C::u64_from_imm64(ctx, v25);
                                                                let v287 =
                                                                    C::u64_mul(ctx, v34, v26);
                                                                let v288 =
                                                                    C::imm64_masked(ctx, v47, v287);
                                                                let v289 = constructor_iconst(
                                                                    ctx, v47, v288,
                                                                );
                                                                let v290 = C::subsume(ctx, v289);
                                                                // Rule at src/opts/cprop.isle line 15.
                                                                returns.push(v290);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v97 = C::simm32(ctx, v33);
                                        if let Some(v98) = v97 {
                                            if v98 == 0x2 {
                                                let v99 = constructor_iadd(ctx, v2.0, v17.1, v17.1);
                                                // Rule at src/opts/algebraic.isle line 204.
                                                returns.push(v99);
                                            }
                                        }
                                        let v105 = C::imm64_power_of_two(ctx, v33);
                                        if let Some(v106) = v105 {
                                            let v107 = C::imm64(ctx, v106);
                                            let v108 = constructor_iconst(ctx, v2.0, v107);
                                            let v109 = constructor_ishl(ctx, v2.0, v17.1, v108);
                                            // Rule at src/opts/algebraic.isle line 213.
                                            returns.push(v109);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    if v2.0 == v21.0 {
                                        let v26 = C::u64_from_imm64(ctx, v25);
                                        match v26 {
                                            0x0 => {
                                                let v35 = C::subsume(ctx, v17.1);
                                                // Rule at src/opts/algebraic.isle line 64.
                                                returns.push(v35);
                                            }
                                            0x1 => {
                                                let v27 = C::subsume(ctx, v17.0);
                                                // Rule at src/opts/algebraic.isle line 54.
                                                returns.push(v27);
                                            }
                                            _ => {}
                                        }
                                        let v54 = C::i64_sextend_imm64(ctx, v2.0, v25);
                                        if v54 == -0x1 {
                                            let v55 = constructor_ineg(ctx, v2.0, v17.0);
                                            // Rule at src/opts/algebraic.isle line 74.
                                            returns.push(v55);
                                        }
                                    }
                                    let v94 = C::simm32(ctx, v25);
                                    if let Some(v95) = v94 {
                                        if v95 == 0x2 {
                                            let v96 = constructor_iadd(ctx, v2.0, v17.0, v17.0);
                                            // Rule at src/opts/algebraic.isle line 202.
                                            returns.push(v96);
                                        }
                                    }
                                    let v100 = C::imm64_power_of_two(ctx, v25);
                                    if let Some(v101) = v100 {
                                        let v102 = C::imm64(ctx, v101);
                                        let v103 = constructor_iconst(ctx, v2.0, v102);
                                        let v104 = constructor_ishl(ctx, v2.0, v17.0, v103);
                                        // Rule at src/opts/algebraic.isle line 211.
                                        returns.push(v104);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Udiv => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x1 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 86.
                                            returns.push(v27);
                                        }
                                    }
                                    let v46 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v47) = v46 {
                                        if v21.0 == v47 {
                                            let v28 = C::inst_data_etor(ctx, v17.0);
                                            let mut v28 = v28;
                                            while let Some(v29) = v28.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v32,
                                                    imm: v33,
                                                } = &v29.1
                                                {
                                                    if let &Opcode::Iconst = v32 {
                                                        let v34 = C::u64_from_imm64(ctx, v33);
                                                        let v296 = C::u64_udiv(ctx, v34, v26);
                                                        if let Some(v297) = v296 {
                                                            if v21.0 == v29.0 {
                                                                let v298 =
                                                                    C::imm64_masked(ctx, v47, v297);
                                                                let v299 = constructor_iconst(
                                                                    ctx, v47, v298,
                                                                );
                                                                let v300 = C::subsume(ctx, v299);
                                                                // Rule at src/opts/cprop.isle line 28.
                                                                returns.push(v300);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sdiv => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x1 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 82.
                                            returns.push(v27);
                                        }
                                    }
                                    let v46 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v47) = v46 {
                                        if v21.0 == v47 {
                                            let v28 = C::inst_data_etor(ctx, v17.0);
                                            let mut v28 = v28;
                                            while let Some(v29) = v28.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v32,
                                                    imm: v33,
                                                } = &v29.1
                                                {
                                                    if let &Opcode::Iconst = v32 {
                                                        let v34 = C::u64_from_imm64(ctx, v33);
                                                        let v291 = C::u64_sdiv(ctx, v34, v26);
                                                        if let Some(v292) = v291 {
                                                            if v21.0 == v29.0 {
                                                                let v293 =
                                                                    C::imm64_masked(ctx, v47, v292);
                                                                let v294 = constructor_iconst(
                                                                    ctx, v47, v293,
                                                                );
                                                                let v295 = C::subsume(ctx, v294);
                                                                // Rule at src/opts/cprop.isle line 21.
                                                                returns.push(v295);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Band => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v28 = C::inst_data_etor(ctx, v17.0);
                        let mut v28 = v28;
                        while let Some(v29) = v28.next(ctx) {
                            match &v29.1 {
                                &InstructionData::Binary {
                                    opcode: ref v70,
                                    args: ref v71,
                                } => {
                                    if let &Opcode::Band = v70 {
                                        if v2.0 == v29.0 {
                                            let v20 = C::inst_data_etor(ctx, v17.1);
                                            let mut v20 = v20;
                                            while let Some(v21) = v20.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v24,
                                                    imm: v25,
                                                } = &v21.1
                                                {
                                                    if let &Opcode::Iconst = v24 {
                                                        if v2.0 == v21.0 {
                                                            let v72 =
                                                                C::unpack_value_array_2(ctx, v71);
                                                            let v82 = C::inst_data_etor(ctx, v72.1);
                                                            let mut v82 = v82;
                                                            while let Some(v83) = v82.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v86,
                                                                    imm: v87,
                                                                } = &v83.1 {
                                                                    if let &Opcode::Iconst = v86 {
                                                                        if v2.0 == v83.0 {
                                                                            let v378 = constructor_band(ctx, v2.0, v72.1, v17.1);
                                                                            let v379 = constructor_band(ctx, v2.0, v72.0, v378);
                                                                            // Rule at src/opts/cprop.isle line 159.
                                                                            returns.push(v379);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v240,
                                    args: ref v241,
                                    cond: ref v242,
                                } => {
                                    if let &Opcode::Icmp = v240 {
                                        let v20 = C::inst_data_etor(ctx, v17.1);
                                        let mut v20 = v20;
                                        while let Some(v21) = v20.next(ctx) {
                                            match &v21.1 {
                                                &InstructionData::IntCompare {
                                                    opcode: ref v265,
                                                    args: ref v266,
                                                    cond: ref v267,
                                                } => {
                                                    if let &Opcode::Icmp = v265 {
                                                        let v271 = constructor_intcc_comparable(
                                                            ctx, v242, v267,
                                                        );
                                                        if let Some(v272) = v271 {
                                                            if v2.0 == v21.0 {
                                                                if v2.0 == v29.0 {
                                                                    let v243 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v241,
                                                                        );
                                                                    let v268 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v266,
                                                                        );
                                                                    if v243.0 == v268.0 {
                                                                        if v243.1 == v268.1 {
                                                                            let v273 = constructor_decompose_intcc(ctx, v242);
                                                                            let v274 = constructor_decompose_intcc(ctx, v267);
                                                                            let v275 = C::u64_and(
                                                                                ctx, v273, v274,
                                                                            );
                                                                            let v276 = constructor_compose_icmp(ctx, v2.0, v275, v272, v243.0, v243.1);
                                                                            // Rule at src/opts/icmp.isle line 128.
                                                                            returns.push(v276);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v24,
                                                    imm: v25,
                                                } => {
                                                    if let &Opcode::Iconst = v24 {
                                                        let v26 = C::u64_from_imm64(ctx, v25);
                                                        if v26 == 0x1 {
                                                            let v238 = C::ty_int(ctx, v2.0);
                                                            if let Some(v239) = v238 {
                                                                // Rule at src/opts/icmp.isle line 39.
                                                                returns.push(v17.0);
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v38,
                                    arg: v39,
                                } => {
                                    match v38 {
                                        &Opcode::Bnot => {
                                            let v46 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v47) = v46 {
                                                let v48 = C::ty_int(ctx, v47);
                                                if let Some(v49) = v48 {
                                                    if v17.1 == v39 {
                                                        if v29.0 == v49 {
                                                            let v51 = C::imm64(ctx, 0x0);
                                                            let v52 =
                                                                constructor_iconst(ctx, v49, v51);
                                                            let v53 = C::subsume(ctx, v52);
                                                            // Rule at src/opts/algebraic.isle line 160.
                                                            returns.push(v53);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Uextend => {
                                            let v20 = C::inst_data_etor(ctx, v17.1);
                                            let mut v20 = v20;
                                            while let Some(v21) = v20.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v24,
                                                    imm: v25,
                                                } = &v21.1
                                                {
                                                    if let &Opcode::Iconst = v24 {
                                                        let v26 = C::u64_from_imm64(ctx, v25);
                                                        if v26 == 0x1 {
                                                            let v238 = C::ty_int(ctx, v2.0);
                                                            if let Some(v239) = v238 {
                                                                let v246 =
                                                                    C::inst_data_etor(ctx, v39);
                                                                let mut v246 = v246;
                                                                while let Some(v247) =
                                                                    v246.next(ctx)
                                                                {
                                                                    if let &InstructionData::IntCompare {
                                                                        opcode: ref v250,
                                                                        args: ref v251,
                                                                        cond: ref v252,
                                                                    } = &v247.1 {
                                                                        if let &Opcode::Icmp = v250 {
                                                                            // Rule at src/opts/icmp.isle line 44.
                                                                            returns.push(v17.0);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        let v132 = C::value_type(ctx, v39);
                                                        let v133 = C::ty_mask(ctx, v132);
                                                        let v134 = C::u64_and(ctx, v26, v133);
                                                        let v135 = C::u64_eq(ctx, v133, v134);
                                                        if v135 == true {
                                                            // Rule at src/opts/algebraic.isle line 282.
                                                            returns.push(v17.0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Sextend => {
                                            let v20 = C::inst_data_etor(ctx, v17.1);
                                            let mut v20 = v20;
                                            while let Some(v21) = v20.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v24,
                                                    imm: v25,
                                                } = &v21.1
                                                {
                                                    if let &Opcode::Iconst = v24 {
                                                        let v26 = C::u64_from_imm64(ctx, v25);
                                                        let v132 = C::value_type(ctx, v39);
                                                        let v133 = C::ty_mask(ctx, v132);
                                                        let v136 = C::u64_eq(ctx, v26, v133);
                                                        if v136 == true {
                                                            let v137 =
                                                                constructor_uextend(ctx, v2.0, v39);
                                                            // Rule at src/opts/algebraic.isle line 288.
                                                            returns.push(v137);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v32,
                                    imm: v33,
                                } => {
                                    if let &Opcode::Iconst = v32 {
                                        if v2.0 == v29.0 {
                                            let v34 = C::u64_from_imm64(ctx, v33);
                                            if v34 == 0x0 {
                                                let v27 = C::subsume(ctx, v17.0);
                                                // Rule at src/opts/algebraic.isle line 158.
                                                returns.push(v27);
                                            }
                                            let v56 = C::i64_sextend_imm64(ctx, v2.0, v33);
                                            if v56 == -0x1 {
                                                let v35 = C::subsume(ctx, v17.1);
                                                // Rule at src/opts/algebraic.isle line 152.
                                                returns.push(v35);
                                            }
                                            let v348 = constructor_band(ctx, v2.0, v17.1, v17.0);
                                            // Rule at src/opts/cprop.isle line 106.
                                            returns.push(v348);
                                        }
                                        let v46 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v47) = v46 {
                                            if v29.0 == v47 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v21.0 == v29.0 {
                                                                let v34 =
                                                                    C::u64_from_imm64(ctx, v33);
                                                                let v26 =
                                                                    C::u64_from_imm64(ctx, v25);
                                                                let v305 =
                                                                    C::u64_and(ctx, v34, v26);
                                                                let v306 =
                                                                    C::imm64_masked(ctx, v47, v305);
                                                                let v307 = constructor_iconst(
                                                                    ctx, v47, v306,
                                                                );
                                                                let v308 = C::subsume(ctx, v307);
                                                                // Rule at src/opts/cprop.isle line 41.
                                                                returns.push(v308);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v138 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 304.
                                        returns.push(v138);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            match &v21.1 {
                                &InstructionData::Unary {
                                    opcode: ref v40,
                                    arg: v41,
                                } => {
                                    if let &Opcode::Bnot = v40 {
                                        if v17.0 == v41 {
                                            let v46 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v47) = v46 {
                                                let v48 = C::ty_int(ctx, v47);
                                                if let Some(v49) = v48 {
                                                    if v21.0 == v49 {
                                                        let v51 = C::imm64(ctx, 0x0);
                                                        let v52 = constructor_iconst(ctx, v49, v51);
                                                        let v53 = C::subsume(ctx, v52);
                                                        // Rule at src/opts/algebraic.isle line 159.
                                                        returns.push(v53);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v24,
                                    imm: v25,
                                } => {
                                    if let &Opcode::Iconst = v24 {
                                        if v2.0 == v21.0 {
                                            let v26 = C::u64_from_imm64(ctx, v25);
                                            if v26 == 0x0 {
                                                let v35 = C::subsume(ctx, v17.1);
                                                // Rule at src/opts/algebraic.isle line 157.
                                                returns.push(v35);
                                            }
                                            let v54 = C::i64_sextend_imm64(ctx, v2.0, v25);
                                            if v54 == -0x1 {
                                                let v27 = C::subsume(ctx, v17.0);
                                                // Rule at src/opts/algebraic.isle line 149.
                                                returns.push(v27);
                                            }
                                        }
                                        let v138 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 306.
                                        returns.push(v138);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v17.0 == v17.1 {
                            let v27 = C::subsume(ctx, v17.0);
                            // Rule at src/opts/algebraic.isle line 148.
                            returns.push(v27);
                        }
                    }
                    &Opcode::Bor => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v28 = C::inst_data_etor(ctx, v17.0);
                        let mut v28 = v28;
                        while let Some(v29) = v28.next(ctx) {
                            match &v29.1 {
                                &InstructionData::Binary {
                                    opcode: ref v70,
                                    args: ref v71,
                                } => {
                                    match v70 {
                                        &Opcode::Band => {
                                            if v2.0 == v29.0 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    match &v21.1 {
                                                        &InstructionData::Unary {
                                                            opcode: ref v40,
                                                            arg: v41,
                                                        } => {
                                                            if let &Opcode::Bnot = v40 {
                                                                if v2.0 == v21.0 {
                                                                    let v72 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v71,
                                                                        );
                                                                    if v41 == v72.1 {
                                                                        let v75 = constructor_bor(
                                                                            ctx, v2.0, v72.0, v17.1,
                                                                        );
                                                                        // Rule at src/opts/algebraic.isle line 174.
                                                                        returns.push(v75);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v24,
                                                            imm: v25,
                                                        } => {
                                                            if let &Opcode::Iconst = v24 {
                                                                if v2.0 == v21.0 {
                                                                    let v72 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v71,
                                                                        );
                                                                    let v82 = C::inst_data_etor(
                                                                        ctx, v72.1,
                                                                    );
                                                                    let mut v82 = v82;
                                                                    while let Some(v83) =
                                                                        v82.next(ctx)
                                                                    {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v86,
                                                                            imm: v87,
                                                                        } = &v83.1 {
                                                                            if let &Opcode::Iconst = v86 {
                                                                                let v89 = C::ty_mask(ctx, v2.0);
                                                                                let v26 = C::u64_from_imm64(ctx, v25);
                                                                                let v90 = C::u64_and(ctx, v89, v26);
                                                                                let v88 = C::u64_from_imm64(ctx, v87);
                                                                                let v91 = C::u64_not(ctx, v88);
                                                                                let v92 = C::u64_and(ctx, v89, v91);
                                                                                let v93 = C::u64_eq(ctx, v90, v92);
                                                                                if v93 == true {
                                                                                    if v2.0 == v83.0 {
                                                                                        let v75 = constructor_bor(ctx, v2.0, v72.0, v17.1);
                                                                                        // Rule at src/opts/algebraic.isle line 194.
                                                                                        returns.push(v75);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v29.0 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v2.0 == v21.0 {
                                                                let v72 = C::unpack_value_array_2(
                                                                    ctx, v71,
                                                                );
                                                                let v82 =
                                                                    C::inst_data_etor(ctx, v72.1);
                                                                let mut v82 = v82;
                                                                while let Some(v83) = v82.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v86,
                                                                        imm: v87,
                                                                    } = &v83.1 {
                                                                        if let &Opcode::Iconst = v86 {
                                                                            if v2.0 == v83.0 {
                                                                                let v376 = constructor_bor(ctx, v2.0, v72.1, v17.1);
                                                                                let v377 = constructor_bor(ctx, v2.0, v72.0, v376);
                                                                                // Rule at src/opts/cprop.isle line 156.
                                                                                returns.push(v377);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v240,
                                    args: ref v241,
                                    cond: ref v242,
                                } => {
                                    if let &Opcode::Icmp = v240 {
                                        if v2.0 == v29.0 {
                                            let v20 = C::inst_data_etor(ctx, v17.1);
                                            let mut v20 = v20;
                                            while let Some(v21) = v20.next(ctx) {
                                                if let &InstructionData::IntCompare {
                                                    opcode: ref v265,
                                                    args: ref v266,
                                                    cond: ref v267,
                                                } = &v21.1
                                                {
                                                    if let &Opcode::Icmp = v265 {
                                                        let v271 = constructor_intcc_comparable(
                                                            ctx, v242, v267,
                                                        );
                                                        if let Some(v272) = v271 {
                                                            if v2.0 == v21.0 {
                                                                let v243 = C::unpack_value_array_2(
                                                                    ctx, v241,
                                                                );
                                                                let v268 = C::unpack_value_array_2(
                                                                    ctx, v266,
                                                                );
                                                                if v243.0 == v268.0 {
                                                                    if v243.1 == v268.1 {
                                                                        let v273 = constructor_decompose_intcc(ctx, v242);
                                                                        let v274 = constructor_decompose_intcc(ctx, v267);
                                                                        let v277 = C::u64_or(
                                                                            ctx, v273, v274,
                                                                        );
                                                                        let v278 = constructor_compose_icmp(ctx, v2.0, v277, v272, v243.0, v243.1);
                                                                        // Rule at src/opts/icmp.isle line 132.
                                                                        returns.push(v278);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v38,
                                    arg: v39,
                                } => {
                                    if let &Opcode::Bnot = v38 {
                                        let v46 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v47) = v46 {
                                            let v48 = C::ty_int(ctx, v47);
                                            if let Some(v49) = v48 {
                                                if v17.1 == v39 {
                                                    if v29.0 == v49 {
                                                        let v57 = C::ty_mask(ctx, v49);
                                                        let v58 = C::imm64(ctx, v57);
                                                        let v59 = constructor_iconst(ctx, v49, v58);
                                                        let v60 = C::subsume(ctx, v59);
                                                        // Rule at src/opts/algebraic.isle line 145.
                                                        returns.push(v60);
                                                    }
                                                }
                                            }
                                        }
                                        if v2.0 == v29.0 {
                                            let v20 = C::inst_data_etor(ctx, v17.1);
                                            let mut v20 = v20;
                                            while let Some(v21) = v20.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v76,
                                                    args: ref v77,
                                                } = &v21.1
                                                {
                                                    if let &Opcode::Band = v76 {
                                                        if v2.0 == v21.0 {
                                                            let v78 =
                                                                C::unpack_value_array_2(ctx, v77);
                                                            if v39 == v78.1 {
                                                                let v81 = constructor_bor(
                                                                    ctx, v2.0, v78.0, v17.0,
                                                                );
                                                                // Rule at src/opts/algebraic.isle line 183.
                                                                returns.push(v81);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v32,
                                    imm: v33,
                                } => {
                                    if let &Opcode::Iconst = v32 {
                                        if v2.0 == v29.0 {
                                            let v34 = C::u64_from_imm64(ctx, v33);
                                            if v34 == 0x0 {
                                                let v35 = C::subsume(ctx, v17.1);
                                                // Rule at src/opts/algebraic.isle line 118.
                                                returns.push(v35);
                                            }
                                            let v347 = constructor_bor(ctx, v2.0, v17.1, v17.0);
                                            // Rule at src/opts/cprop.isle line 103.
                                            returns.push(v347);
                                        }
                                        let v46 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v47) = v46 {
                                            if v29.0 == v47 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v21.0 == v29.0 {
                                                                let v34 =
                                                                    C::u64_from_imm64(ctx, v33);
                                                                let v26 =
                                                                    C::u64_from_imm64(ctx, v25);
                                                                let v301 = C::u64_or(ctx, v34, v26);
                                                                let v302 =
                                                                    C::imm64_masked(ctx, v47, v301);
                                                                let v303 = constructor_iconst(
                                                                    ctx, v47, v302,
                                                                );
                                                                let v304 = C::subsume(ctx, v303);
                                                                // Rule at src/opts/cprop.isle line 35.
                                                                returns.push(v304);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v138 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 308.
                                        returns.push(v138);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            match &v21.1 {
                                &InstructionData::Unary {
                                    opcode: ref v40,
                                    arg: v41,
                                } => {
                                    if let &Opcode::Bnot = v40 {
                                        if v17.0 == v41 {
                                            let v46 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v47) = v46 {
                                                let v48 = C::ty_int(ctx, v47);
                                                if let Some(v49) = v48 {
                                                    if v21.0 == v49 {
                                                        let v57 = C::ty_mask(ctx, v49);
                                                        let v58 = C::imm64(ctx, v57);
                                                        let v59 = constructor_iconst(ctx, v49, v58);
                                                        let v60 = C::subsume(ctx, v59);
                                                        // Rule at src/opts/algebraic.isle line 144.
                                                        returns.push(v60);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v24,
                                    imm: v25,
                                } => {
                                    if let &Opcode::Iconst = v24 {
                                        let v26 = C::u64_from_imm64(ctx, v25);
                                        if v26 == 0x0 {
                                            if v2.0 == v21.0 {
                                                let v27 = C::subsume(ctx, v17.0);
                                                // Rule at src/opts/algebraic.isle line 114.
                                                returns.push(v27);
                                            }
                                        }
                                        let v138 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 310.
                                        returns.push(v138);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v17.0 == v17.1 {
                            let v27 = C::subsume(ctx, v17.0);
                            // Rule at src/opts/algebraic.isle line 122.
                            returns.push(v27);
                        }
                    }
                    &Opcode::Bxor => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            match &v21.1 {
                                &InstructionData::Unary {
                                    opcode: ref v40,
                                    arg: v41,
                                } => {
                                    if let &Opcode::Bnot = v40 {
                                        let v46 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v47) = v46 {
                                            let v48 = C::ty_int(ctx, v47);
                                            if let Some(v49) = v48 {
                                                if v17.0 == v41 {
                                                    if v21.0 == v49 {
                                                        let v57 = C::ty_mask(ctx, v49);
                                                        let v58 = C::imm64(ctx, v57);
                                                        let v59 = constructor_iconst(ctx, v49, v58);
                                                        let v60 = C::subsume(ctx, v59);
                                                        // Rule at src/opts/algebraic.isle line 142.
                                                        returns.push(v60);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v24,
                                    imm: v25,
                                } => {
                                    if let &Opcode::Iconst = v24 {
                                        if v2.0 == v21.0 {
                                            let v26 = C::u64_from_imm64(ctx, v25);
                                            if v26 == 0x0 {
                                                let v27 = C::subsume(ctx, v17.0);
                                                // Rule at src/opts/algebraic.isle line 126.
                                                returns.push(v27);
                                            }
                                            let v54 = C::i64_sextend_imm64(ctx, v2.0, v25);
                                            if v54 == -0x1 {
                                                let v145 = constructor_bnot(ctx, v2.0, v17.0);
                                                // Rule at src/opts/algebraic.isle line 326.
                                                returns.push(v145);
                                            }
                                            let v28 = C::inst_data_etor(ctx, v17.0);
                                            let mut v28 = v28;
                                            while let Some(v29) = v28.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v70,
                                                    args: ref v71,
                                                } = &v29.1
                                                {
                                                    if let &Opcode::Bxor = v70 {
                                                        if v2.0 == v29.0 {
                                                            let v72 =
                                                                C::unpack_value_array_2(ctx, v71);
                                                            let v82 = C::inst_data_etor(ctx, v72.1);
                                                            let mut v82 = v82;
                                                            while let Some(v83) = v82.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v86,
                                                                    imm: v87,
                                                                } = &v83.1 {
                                                                    if let &Opcode::Iconst = v86 {
                                                                        if v2.0 == v83.0 {
                                                                            let v380 = constructor_bxor(ctx, v2.0, v72.1, v17.1);
                                                                            let v381 = constructor_bxor(ctx, v2.0, v72.0, v380);
                                                                            // Rule at src/opts/cprop.isle line 162.
                                                                            returns.push(v381);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v46 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v47) = v46 {
                                            if v21.0 == v47 {
                                                let v28 = C::inst_data_etor(ctx, v17.0);
                                                let mut v28 = v28;
                                                while let Some(v29) = v28.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v32,
                                                        imm: v33,
                                                    } = &v29.1
                                                    {
                                                        if let &Opcode::Iconst = v32 {
                                                            if v21.0 == v29.0 {
                                                                let v34 =
                                                                    C::u64_from_imm64(ctx, v33);
                                                                let v26 =
                                                                    C::u64_from_imm64(ctx, v25);
                                                                let v309 =
                                                                    C::u64_xor(ctx, v34, v26);
                                                                let v310 =
                                                                    C::imm64_masked(ctx, v47, v309);
                                                                let v311 = constructor_iconst(
                                                                    ctx, v47, v310,
                                                                );
                                                                let v312 = C::subsume(ctx, v311);
                                                                // Rule at src/opts/cprop.isle line 47.
                                                                returns.push(v312);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v138 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 314.
                                        returns.push(v138);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v28 = C::inst_data_etor(ctx, v17.0);
                        let mut v28 = v28;
                        while let Some(v29) = v28.next(ctx) {
                            match &v29.1 {
                                &InstructionData::Unary {
                                    opcode: ref v38,
                                    arg: v39,
                                } => {
                                    if let &Opcode::Bnot = v38 {
                                        if v17.1 == v39 {
                                            let v46 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v47) = v46 {
                                                let v48 = C::ty_int(ctx, v47);
                                                if let Some(v49) = v48 {
                                                    if v29.0 == v49 {
                                                        let v57 = C::ty_mask(ctx, v49);
                                                        let v58 = C::imm64(ctx, v57);
                                                        let v59 = constructor_iconst(ctx, v49, v58);
                                                        let v60 = C::subsume(ctx, v59);
                                                        // Rule at src/opts/algebraic.isle line 143.
                                                        returns.push(v60);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v32,
                                    imm: v33,
                                } => {
                                    if let &Opcode::Iconst = v32 {
                                        if v2.0 == v29.0 {
                                            let v34 = C::u64_from_imm64(ctx, v33);
                                            if v34 == 0x0 {
                                                let v35 = C::subsume(ctx, v17.1);
                                                // Rule at src/opts/algebraic.isle line 130.
                                                returns.push(v35);
                                            }
                                            let v349 = constructor_bxor(ctx, v2.0, v17.1, v17.0);
                                            // Rule at src/opts/cprop.isle line 109.
                                            returns.push(v349);
                                        }
                                        let v138 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 312.
                                        returns.push(v138);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v17.0 == v17.1 {
                            let v46 = C::fits_in_64(ctx, v2.0);
                            if let Some(v47) = v46 {
                                let v48 = C::ty_int(ctx, v47);
                                if let Some(v49) = v48 {
                                    let v51 = C::imm64(ctx, 0x0);
                                    let v52 = constructor_iconst(ctx, v49, v51);
                                    let v53 = C::subsume(ctx, v52);
                                    // Rule at src/opts/algebraic.isle line 136.
                                    returns.push(v53);
                                }
                            }
                        }
                    }
                    &Opcode::Rotl => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x0 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 108.
                                            returns.push(v27);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Rotr => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x0 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 104.
                                            returns.push(v27);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ishl => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v46 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v47) = v46 {
                                        let v28 = C::inst_data_etor(ctx, v17.0);
                                        let mut v28 = v28;
                                        while let Some(v29) = v28.next(ctx) {
                                            match &v29.1 {
                                                &InstructionData::Binary {
                                                    opcode: ref v70,
                                                    args: ref v71,
                                                } => {
                                                    match v70 {
                                                        &Opcode::Ushr => {
                                                            if v29.0 == v47 {
                                                                let v72 = C::unpack_value_array_2(
                                                                    ctx, v71,
                                                                );
                                                                let v82 =
                                                                    C::inst_data_etor(ctx, v72.1);
                                                                let mut v82 = v82;
                                                                while let Some(v83) = v82.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v86,
                                                                        imm: v87,
                                                                    } = &v83.1 {
                                                                        if let &Opcode::Iconst = v86 {
                                                                            if v25 == v87 {
                                                                                let v111 = C::imm64(ctx, 0xFFFFFFFFFFFFFFFF);
                                                                                let v112 = C::imm64_shl(ctx, v47, v111, v87);
                                                                                let v113 = constructor_iconst(ctx, v47, v112);
                                                                                let v114 = constructor_band(ctx, v47, v72.0, v113);
                                                                                // Rule at src/opts/algebraic.isle line 222.
                                                                                returns.push(v114);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Sshr => {
                                                            if v29.0 == v47 {
                                                                let v72 = C::unpack_value_array_2(
                                                                    ctx, v71,
                                                                );
                                                                let v82 =
                                                                    C::inst_data_etor(ctx, v72.1);
                                                                let mut v82 = v82;
                                                                while let Some(v83) = v82.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v86,
                                                                        imm: v87,
                                                                    } = &v83.1 {
                                                                        if let &Opcode::Iconst = v86 {
                                                                            if v25 == v87 {
                                                                                let v111 = C::imm64(ctx, 0xFFFFFFFFFFFFFFFF);
                                                                                let v112 = C::imm64_shl(ctx, v47, v111, v87);
                                                                                let v113 = constructor_iconst(ctx, v47, v112);
                                                                                let v114 = constructor_band(ctx, v47, v72.0, v113);
                                                                                // Rule at src/opts/algebraic.isle line 227.
                                                                                returns.push(v114);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v32,
                                                    imm: v33,
                                                } => {
                                                    if let &Opcode::Iconst = v32 {
                                                        if v29.0 == v47 {
                                                            let v320 =
                                                                C::imm64_shl(ctx, v47, v33, v25);
                                                            let v321 =
                                                                constructor_iconst(ctx, v47, v320);
                                                            let v322 = C::subsume(ctx, v321);
                                                            // Rule at src/opts/cprop.isle line 58.
                                                            returns.push(v322);
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x0 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 92.
                                            returns.push(v27);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v46 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v47) = v46 {
                                        let v28 = C::inst_data_etor(ctx, v17.0);
                                        let mut v28 = v28;
                                        while let Some(v29) = v28.next(ctx) {
                                            match &v29.1 {
                                                &InstructionData::Binary {
                                                    opcode: ref v70,
                                                    args: ref v71,
                                                } => {
                                                    if let &Opcode::Ishl = v70 {
                                                        let v48 = C::ty_int(ctx, v47);
                                                        if let Some(v49) = v48 {
                                                            if v29.0 == v49 {
                                                                let v72 = C::unpack_value_array_2(
                                                                    ctx, v71,
                                                                );
                                                                let v82 =
                                                                    C::inst_data_etor(ctx, v72.1);
                                                                let mut v82 = v82;
                                                                while let Some(v83) = v82.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v86,
                                                                        imm: v87,
                                                                    } = &v83.1 {
                                                                        if let &Opcode::Iconst = v86 {
                                                                            if v25 == v87 {
                                                                                let v57 = C::ty_mask(ctx, v49);
                                                                                let v58 = C::imm64(ctx, v57);
                                                                                let v115 = C::imm64_ushr(ctx, v49, v58, v87);
                                                                                let v116 = constructor_iconst(ctx, v49, v115);
                                                                                let v117 = constructor_band(ctx, v49, v72.0, v116);
                                                                                // Rule at src/opts/algebraic.isle line 237.
                                                                                returns.push(v117);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v32,
                                                    imm: v33,
                                                } => {
                                                    if let &Opcode::Iconst = v32 {
                                                        if v29.0 == v47 {
                                                            let v323 =
                                                                C::imm64_ushr(ctx, v47, v33, v25);
                                                            let v324 =
                                                                constructor_iconst(ctx, v47, v323);
                                                            let v325 = C::subsume(ctx, v324);
                                                            // Rule at src/opts/cprop.isle line 63.
                                                            returns.push(v325);
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x0 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 96.
                                            returns.push(v27);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v28 = C::inst_data_etor(ctx, v17.0);
                                    let mut v28 = v28;
                                    while let Some(v29) = v28.next(ctx) {
                                        match &v29.1 {
                                            &InstructionData::Binary {
                                                opcode: ref v70,
                                                args: ref v71,
                                            } => {
                                                if let &Opcode::Ishl = v70 {
                                                    if v2.0 == v29.0 {
                                                        let v72 = C::unpack_value_array_2(ctx, v71);
                                                        let v82 = C::inst_data_etor(ctx, v72.1);
                                                        let mut v82 = v82;
                                                        while let Some(v83) = v82.next(ctx) {
                                                            if let &InstructionData::UnaryImm {
                                                                opcode: ref v86,
                                                                imm: v87,
                                                            } = &v83.1
                                                            {
                                                                if let &Opcode::Iconst = v86 {
                                                                    if v25 == v87 {
                                                                        let v118 =
                                                                            C::inst_data_etor(
                                                                                ctx, v72.0,
                                                                            );
                                                                        let mut v118 = v118;
                                                                        while let Some(v119) =
                                                                            v118.next(ctx)
                                                                        {
                                                                            if let &InstructionData::Unary {
                                                                                opcode: ref v122,
                                                                                arg: v123,
                                                                            } = &v119.1 {
                                                                                match v122 {
                                                                                    &Opcode::Uextend => {
                                                                                        if v2.0 == v119.0 {
                                                                                            let v88 = C::u64_from_imm64(ctx, v87);
                                                                                            let v125 = C::ty_bits_u64(ctx, v2.0);
                                                                                            let v124 = C::value_type(ctx, v123);
                                                                                            let v126 = C::ty_bits_u64(ctx, v124);
                                                                                            let v127 = C::u64_sub(ctx, v125, v126);
                                                                                            let v128 = C::u64_eq(ctx, v88, v127);
                                                                                            if v128 == true {
                                                                                                let v129 = constructor_sextend(ctx, v2.0, v123);
                                                                                                // Rule at src/opts/algebraic.isle line 247.
                                                                                                returns.push(v129);
                                                                                            }
                                                                                            let v130 = C::u64_lt(ctx, v88, v127);
                                                                                            if v130 == true {
                                                                                                // Rule at src/opts/algebraic.isle line 259.
                                                                                                returns.push(v72.0);
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    &Opcode::Sextend => {
                                                                                        let v88 = C::u64_from_imm64(ctx, v87);
                                                                                        let v125 = C::ty_bits_u64(ctx, v2.0);
                                                                                        let v124 = C::value_type(ctx, v123);
                                                                                        let v126 = C::ty_bits_u64(ctx, v124);
                                                                                        let v127 = C::u64_sub(ctx, v125, v126);
                                                                                        let v131 = C::u64_le(ctx, v88, v127);
                                                                                        if v131 == true {
                                                                                            if v2.0 == v119.0 {
                                                                                                // Rule at src/opts/algebraic.isle line 270.
                                                                                                returns.push(v72.0);
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    _ => {}
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &InstructionData::UnaryImm {
                                                opcode: ref v32,
                                                imm: v33,
                                            } => {
                                                if let &Opcode::Iconst = v32 {
                                                    let v46 = C::fits_in_64(ctx, v2.0);
                                                    if let Some(v47) = v46 {
                                                        if v29.0 == v47 {
                                                            let v326 =
                                                                C::imm64_sshr(ctx, v47, v33, v25);
                                                            let v327 =
                                                                constructor_iconst(ctx, v47, v326);
                                                            let v328 = C::subsume(ctx, v327);
                                                            // Rule at src/opts/cprop.isle line 68.
                                                            returns.push(v328);
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x0 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 100.
                                            returns.push(v27);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Fmul => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v40,
                                arg: v41,
                            } = &v21.1
                            {
                                if let &Opcode::Fneg = v40 {
                                    if v2.0 == v21.0 {
                                        let v28 = C::inst_data_etor(ctx, v17.0);
                                        let mut v28 = v28;
                                        while let Some(v29) = v28.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v38,
                                                arg: v39,
                                            } = &v29.1
                                            {
                                                if let &Opcode::Fneg = v38 {
                                                    if v2.0 == v29.0 {
                                                        let v211 =
                                                            constructor_fmul(ctx, v2.0, v39, v41);
                                                        // Rule at src/opts/algebraic.isle line 410.
                                                        returns.push(v211);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::IntCompare {
                opcode: ref v146,
                args: ref v147,
                cond: ref v148,
            } => {
                if let &Opcode::Icmp = v146 {
                    match v148 {
                        &IntCC::Equal => {
                            let v46 = C::fits_in_64(ctx, v2.0);
                            if let Some(v47) = v46 {
                                let v48 = C::ty_int(ctx, v47);
                                if let Some(v49) = v48 {
                                    let v149 = C::unpack_value_array_2(ctx, v147);
                                    if v149.0 == v149.1 {
                                        let v168 = C::imm64(ctx, 0x1);
                                        let v212 = constructor_iconst(ctx, v49, v168);
                                        // Rule at src/opts/icmp.isle line 5.
                                        returns.push(v212);
                                    }
                                }
                            }
                            let v149 = C::unpack_value_array_2(ctx, v147);
                            let v152 = C::inst_data_etor(ctx, v149.0);
                            let mut v152 = v152;
                            while let Some(v153) = v152.next(ctx) {
                                if let &InstructionData::Unary {
                                    opcode: ref v156,
                                    arg: v157,
                                } = &v153.1
                                {
                                    if let &Opcode::Uextend = v156 {
                                        let v159 = C::inst_data_etor(ctx, v149.1);
                                        let mut v159 = v159;
                                        while let Some(v160) = v159.next(ctx) {
                                            if let &InstructionData::UnaryImm {
                                                opcode: ref v163,
                                                imm: v164,
                                            } = &v160.1
                                            {
                                                if let &Opcode::Iconst = v163 {
                                                    let v165 = C::u64_from_imm64(ctx, v164);
                                                    if v165 == 0x0 {
                                                        let v213 = C::inst_data_etor(ctx, v157);
                                                        let mut v213 = v213;
                                                        while let Some(v214) = v213.next(ctx) {
                                                            if let &InstructionData::IntCompare {
                                                                opcode: ref v217,
                                                                args: ref v218,
                                                                cond: ref v219,
                                                            } = &v214.1
                                                            {
                                                                if let &Opcode::Icmp = v217 {
                                                                    if v2.0 == v214.0 {
                                                                        let v224 =
                                                                            &C::intcc_inverse(
                                                                                ctx, v219,
                                                                            );
                                                                        let v220 =
                                                                            C::unpack_value_array_2(
                                                                                ctx, v218,
                                                                            );
                                                                        let v225 = constructor_icmp(
                                                                            ctx, v2.0, v224,
                                                                            v220.0, v220.1,
                                                                        );
                                                                        let v226 =
                                                                            C::subsume(ctx, v225);
                                                                        // Rule at src/opts/icmp.isle line 22.
                                                                        returns.push(v226);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::NotEqual => {
                            let v46 = C::fits_in_64(ctx, v2.0);
                            if let Some(v47) = v46 {
                                let v48 = C::ty_int(ctx, v47);
                                if let Some(v49) = v48 {
                                    let v149 = C::unpack_value_array_2(ctx, v147);
                                    if v149.0 == v149.1 {
                                        let v51 = C::imm64(ctx, 0x0);
                                        let v52 = constructor_iconst(ctx, v49, v51);
                                        // Rule at src/opts/icmp.isle line 6.
                                        returns.push(v52);
                                    }
                                }
                            }
                            let v149 = C::unpack_value_array_2(ctx, v147);
                            let v152 = C::inst_data_etor(ctx, v149.0);
                            let mut v152 = v152;
                            while let Some(v153) = v152.next(ctx) {
                                if let &InstructionData::Unary {
                                    opcode: ref v156,
                                    arg: v157,
                                } = &v153.1
                                {
                                    if let &Opcode::Uextend = v156 {
                                        let v159 = C::inst_data_etor(ctx, v149.1);
                                        let mut v159 = v159;
                                        while let Some(v160) = v159.next(ctx) {
                                            if let &InstructionData::UnaryImm {
                                                opcode: ref v163,
                                                imm: v164,
                                            } = &v160.1
                                            {
                                                if let &Opcode::Iconst = v163 {
                                                    let v165 = C::u64_from_imm64(ctx, v164);
                                                    if v165 == 0x0 {
                                                        let v213 = C::inst_data_etor(ctx, v157);
                                                        let mut v213 = v213;
                                                        while let Some(v214) = v213.next(ctx) {
                                                            if let &InstructionData::IntCompare {
                                                                opcode: ref v217,
                                                                args: ref v218,
                                                                cond: ref v219,
                                                            } = &v214.1
                                                            {
                                                                if let &Opcode::Icmp = v217 {
                                                                    if v2.0 == v214.0 {
                                                                        let v223 =
                                                                            C::subsume(ctx, v157);
                                                                        // Rule at src/opts/icmp.isle line 17.
                                                                        returns.push(v223);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedGreaterThan => {
                            let v46 = C::fits_in_64(ctx, v2.0);
                            if let Some(v47) = v46 {
                                let v48 = C::ty_int(ctx, v47);
                                if let Some(v49) = v48 {
                                    let v149 = C::unpack_value_array_2(ctx, v147);
                                    let v159 = C::inst_data_etor(ctx, v149.1);
                                    let mut v159 = v159;
                                    while let Some(v160) = v159.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v163,
                                            imm: v164,
                                        } = &v160.1
                                        {
                                            if let &Opcode::Iconst = v163 {
                                                let v165 = C::u64_from_imm64(ctx, v164);
                                                let v261 = C::ty_smin(ctx, v160.0);
                                                let v262 = C::u64_eq(ctx, v165, v261);
                                                if v262 == true {
                                                    let v257 =
                                                        constructor_ne(ctx, v49, v149.0, v149.1);
                                                    // Rule at src/opts/icmp.isle line 98.
                                                    returns.push(v257);
                                                }
                                                let v263 = C::ty_smax(ctx, v160.0);
                                                let v264 = C::u64_eq(ctx, v165, v263);
                                                if v264 == true {
                                                    let v51 = C::imm64(ctx, 0x0);
                                                    let v52 = constructor_iconst(ctx, v49, v51);
                                                    let v53 = C::subsume(ctx, v52);
                                                    // Rule at src/opts/icmp.isle line 118.
                                                    returns.push(v53);
                                                }
                                            }
                                        }
                                    }
                                    if v149.0 == v149.1 {
                                        let v51 = C::imm64(ctx, 0x0);
                                        let v52 = constructor_iconst(ctx, v49, v51);
                                        // Rule at src/opts/icmp.isle line 9.
                                        returns.push(v52);
                                    }
                                }
                            }
                        }
                        &IntCC::SignedGreaterThanOrEqual => {
                            let v46 = C::fits_in_64(ctx, v2.0);
                            if let Some(v47) = v46 {
                                let v48 = C::ty_int(ctx, v47);
                                if let Some(v49) = v48 {
                                    let v149 = C::unpack_value_array_2(ctx, v147);
                                    let v159 = C::inst_data_etor(ctx, v149.1);
                                    let mut v159 = v159;
                                    while let Some(v160) = v159.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v163,
                                            imm: v164,
                                        } = &v160.1
                                        {
                                            if let &Opcode::Iconst = v163 {
                                                let v165 = C::u64_from_imm64(ctx, v164);
                                                let v261 = C::ty_smin(ctx, v160.0);
                                                let v262 = C::u64_eq(ctx, v165, v261);
                                                if v262 == true {
                                                    let v168 = C::imm64(ctx, 0x1);
                                                    let v212 = constructor_iconst(ctx, v49, v168);
                                                    let v258 = C::subsume(ctx, v212);
                                                    // Rule at src/opts/icmp.isle line 103.
                                                    returns.push(v258);
                                                }
                                                let v263 = C::ty_smax(ctx, v160.0);
                                                let v264 = C::u64_eq(ctx, v165, v263);
                                                if v264 == true {
                                                    let v256 =
                                                        constructor_eq(ctx, v49, v149.0, v149.1);
                                                    // Rule at src/opts/icmp.isle line 123.
                                                    returns.push(v256);
                                                }
                                            }
                                        }
                                    }
                                    if v149.0 == v149.1 {
                                        let v168 = C::imm64(ctx, 0x1);
                                        let v212 = constructor_iconst(ctx, v49, v168);
                                        // Rule at src/opts/icmp.isle line 10.
                                        returns.push(v212);
                                    }
                                }
                            }
                            let v149 = C::unpack_value_array_2(ctx, v147);
                            let v152 = C::inst_data_etor(ctx, v149.0);
                            let mut v152 = v152;
                            while let Some(v153) = v152.next(ctx) {
                                if v153.0 == I64 {
                                    if let &InstructionData::Unary {
                                        opcode: ref v156,
                                        arg: v157,
                                    } = &v153.1
                                    {
                                        if let &Opcode::Uextend = v156 {
                                            let v158 = C::value_type(ctx, v157);
                                            if v158 == I32 {
                                                let v159 = C::inst_data_etor(ctx, v149.1);
                                                let mut v159 = v159;
                                                while let Some(v160) = v159.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v163,
                                                        imm: v164,
                                                    } = &v160.1
                                                    {
                                                        if let &Opcode::Iconst = v163 {
                                                            let v165 = C::u64_from_imm64(ctx, v164);
                                                            if v165 == 0x0 {
                                                                let v168 = C::imm64(ctx, 0x1);
                                                                let v169 = constructor_iconst(
                                                                    ctx, v2.0, v168,
                                                                );
                                                                // Rule at src/opts/algebraic.isle line 336.
                                                                returns.push(v169);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedLessThan => {
                            let v46 = C::fits_in_64(ctx, v2.0);
                            if let Some(v47) = v46 {
                                let v48 = C::ty_int(ctx, v47);
                                if let Some(v49) = v48 {
                                    let v149 = C::unpack_value_array_2(ctx, v147);
                                    let v159 = C::inst_data_etor(ctx, v149.1);
                                    let mut v159 = v159;
                                    while let Some(v160) = v159.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v163,
                                            imm: v164,
                                        } = &v160.1
                                        {
                                            if let &Opcode::Iconst = v163 {
                                                let v165 = C::u64_from_imm64(ctx, v164);
                                                let v261 = C::ty_smin(ctx, v160.0);
                                                let v262 = C::u64_eq(ctx, v165, v261);
                                                if v262 == true {
                                                    let v51 = C::imm64(ctx, 0x0);
                                                    let v52 = constructor_iconst(ctx, v49, v51);
                                                    let v53 = C::subsume(ctx, v52);
                                                    // Rule at src/opts/icmp.isle line 88.
                                                    returns.push(v53);
                                                }
                                                let v263 = C::ty_smax(ctx, v160.0);
                                                let v264 = C::u64_eq(ctx, v165, v263);
                                                if v264 == true {
                                                    let v257 =
                                                        constructor_ne(ctx, v49, v149.0, v149.1);
                                                    // Rule at src/opts/icmp.isle line 108.
                                                    returns.push(v257);
                                                }
                                            }
                                        }
                                    }
                                    if v149.0 == v149.1 {
                                        let v51 = C::imm64(ctx, 0x0);
                                        let v52 = constructor_iconst(ctx, v49, v51);
                                        // Rule at src/opts/icmp.isle line 13.
                                        returns.push(v52);
                                    }
                                }
                            }
                            let v149 = C::unpack_value_array_2(ctx, v147);
                            let v152 = C::inst_data_etor(ctx, v149.0);
                            let mut v152 = v152;
                            while let Some(v153) = v152.next(ctx) {
                                if v153.0 == I64 {
                                    if let &InstructionData::Unary {
                                        opcode: ref v156,
                                        arg: v157,
                                    } = &v153.1
                                    {
                                        if let &Opcode::Uextend = v156 {
                                            let v158 = C::value_type(ctx, v157);
                                            if v158 == I32 {
                                                let v159 = C::inst_data_etor(ctx, v149.1);
                                                let mut v159 = v159;
                                                while let Some(v160) = v159.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v163,
                                                        imm: v164,
                                                    } = &v160.1
                                                    {
                                                        if let &Opcode::Iconst = v163 {
                                                            let v165 = C::u64_from_imm64(ctx, v164);
                                                            if v165 == 0x0 {
                                                                let v51 = C::imm64(ctx, 0x0);
                                                                let v166 = constructor_iconst(
                                                                    ctx, v2.0, v51,
                                                                );
                                                                // Rule at src/opts/algebraic.isle line 331.
                                                                returns.push(v166);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedLessThanOrEqual => {
                            let v46 = C::fits_in_64(ctx, v2.0);
                            if let Some(v47) = v46 {
                                let v48 = C::ty_int(ctx, v47);
                                if let Some(v49) = v48 {
                                    let v149 = C::unpack_value_array_2(ctx, v147);
                                    let v159 = C::inst_data_etor(ctx, v149.1);
                                    let mut v159 = v159;
                                    while let Some(v160) = v159.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v163,
                                            imm: v164,
                                        } = &v160.1
                                        {
                                            if let &Opcode::Iconst = v163 {
                                                let v165 = C::u64_from_imm64(ctx, v164);
                                                let v261 = C::ty_smin(ctx, v160.0);
                                                let v262 = C::u64_eq(ctx, v165, v261);
                                                if v262 == true {
                                                    let v256 =
                                                        constructor_eq(ctx, v49, v149.0, v149.1);
                                                    // Rule at src/opts/icmp.isle line 93.
                                                    returns.push(v256);
                                                }
                                                let v263 = C::ty_smax(ctx, v160.0);
                                                let v264 = C::u64_eq(ctx, v165, v263);
                                                if v264 == true {
                                                    let v168 = C::imm64(ctx, 0x1);
                                                    let v212 = constructor_iconst(ctx, v49, v168);
                                                    let v258 = C::subsume(ctx, v212);
                                                    // Rule at src/opts/icmp.isle line 113.
                                                    returns.push(v258);
                                                }
                                            }
                                        }
                                    }
                                    if v149.0 == v149.1 {
                                        let v168 = C::imm64(ctx, 0x1);
                                        let v212 = constructor_iconst(ctx, v49, v168);
                                        // Rule at src/opts/icmp.isle line 14.
                                        returns.push(v212);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedGreaterThan => {
                            let v46 = C::fits_in_64(ctx, v2.0);
                            if let Some(v47) = v46 {
                                let v48 = C::ty_int(ctx, v47);
                                if let Some(v49) = v48 {
                                    let v149 = C::unpack_value_array_2(ctx, v147);
                                    let v159 = C::inst_data_etor(ctx, v149.1);
                                    let mut v159 = v159;
                                    while let Some(v160) = v159.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v163,
                                            imm: v164,
                                        } = &v160.1
                                        {
                                            if let &Opcode::Iconst = v163 {
                                                let v165 = C::u64_from_imm64(ctx, v164);
                                                if v165 == 0x0 {
                                                    let v257 =
                                                        constructor_ne(ctx, v49, v149.0, v149.1);
                                                    // Rule at src/opts/icmp.isle line 60.
                                                    returns.push(v257);
                                                }
                                                let v259 = C::ty_umax(ctx, v160.0);
                                                let v260 = C::u64_eq(ctx, v165, v259);
                                                if v260 == true {
                                                    let v51 = C::imm64(ctx, 0x0);
                                                    let v52 = constructor_iconst(ctx, v49, v51);
                                                    let v53 = C::subsume(ctx, v52);
                                                    // Rule at src/opts/icmp.isle line 78.
                                                    returns.push(v53);
                                                }
                                            }
                                        }
                                    }
                                    if v149.0 == v149.1 {
                                        let v51 = C::imm64(ctx, 0x0);
                                        let v52 = constructor_iconst(ctx, v49, v51);
                                        // Rule at src/opts/icmp.isle line 7.
                                        returns.push(v52);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedGreaterThanOrEqual => {
                            let v46 = C::fits_in_64(ctx, v2.0);
                            if let Some(v47) = v46 {
                                let v48 = C::ty_int(ctx, v47);
                                if let Some(v49) = v48 {
                                    let v149 = C::unpack_value_array_2(ctx, v147);
                                    let v159 = C::inst_data_etor(ctx, v149.1);
                                    let mut v159 = v159;
                                    while let Some(v160) = v159.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v163,
                                            imm: v164,
                                        } = &v160.1
                                        {
                                            if let &Opcode::Iconst = v163 {
                                                let v165 = C::u64_from_imm64(ctx, v164);
                                                if v165 == 0x0 {
                                                    let v168 = C::imm64(ctx, 0x1);
                                                    let v212 = constructor_iconst(ctx, v49, v168);
                                                    let v258 = C::subsume(ctx, v212);
                                                    // Rule at src/opts/icmp.isle line 64.
                                                    returns.push(v258);
                                                }
                                                let v259 = C::ty_umax(ctx, v160.0);
                                                let v260 = C::u64_eq(ctx, v165, v259);
                                                if v260 == true {
                                                    let v256 =
                                                        constructor_eq(ctx, v49, v149.0, v149.1);
                                                    // Rule at src/opts/icmp.isle line 83.
                                                    returns.push(v256);
                                                }
                                            }
                                        }
                                    }
                                    if v149.0 == v149.1 {
                                        let v168 = C::imm64(ctx, 0x1);
                                        let v212 = constructor_iconst(ctx, v49, v168);
                                        // Rule at src/opts/icmp.isle line 8.
                                        returns.push(v212);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedLessThan => {
                            let v46 = C::fits_in_64(ctx, v2.0);
                            if let Some(v47) = v46 {
                                let v48 = C::ty_int(ctx, v47);
                                if let Some(v49) = v48 {
                                    let v149 = C::unpack_value_array_2(ctx, v147);
                                    let v159 = C::inst_data_etor(ctx, v149.1);
                                    let mut v159 = v159;
                                    while let Some(v160) = v159.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v163,
                                            imm: v164,
                                        } = &v160.1
                                        {
                                            if let &Opcode::Iconst = v163 {
                                                let v165 = C::u64_from_imm64(ctx, v164);
                                                if v165 == 0x0 {
                                                    let v51 = C::imm64(ctx, 0x0);
                                                    let v52 = constructor_iconst(ctx, v49, v51);
                                                    let v53 = C::subsume(ctx, v52);
                                                    // Rule at src/opts/icmp.isle line 52.
                                                    returns.push(v53);
                                                }
                                                let v259 = C::ty_umax(ctx, v160.0);
                                                let v260 = C::u64_eq(ctx, v165, v259);
                                                if v260 == true {
                                                    let v257 =
                                                        constructor_ne(ctx, v49, v149.0, v149.1);
                                                    // Rule at src/opts/icmp.isle line 68.
                                                    returns.push(v257);
                                                }
                                            }
                                        }
                                    }
                                    if v149.0 == v149.1 {
                                        let v51 = C::imm64(ctx, 0x0);
                                        let v52 = constructor_iconst(ctx, v49, v51);
                                        // Rule at src/opts/icmp.isle line 11.
                                        returns.push(v52);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedLessThanOrEqual => {
                            let v46 = C::fits_in_64(ctx, v2.0);
                            if let Some(v47) = v46 {
                                let v48 = C::ty_int(ctx, v47);
                                if let Some(v49) = v48 {
                                    let v149 = C::unpack_value_array_2(ctx, v147);
                                    let v159 = C::inst_data_etor(ctx, v149.1);
                                    let mut v159 = v159;
                                    while let Some(v160) = v159.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v163,
                                            imm: v164,
                                        } = &v160.1
                                        {
                                            if let &Opcode::Iconst = v163 {
                                                let v165 = C::u64_from_imm64(ctx, v164);
                                                if v165 == 0x0 {
                                                    let v256 =
                                                        constructor_eq(ctx, v49, v149.0, v149.1);
                                                    // Rule at src/opts/icmp.isle line 56.
                                                    returns.push(v256);
                                                }
                                                let v259 = C::ty_umax(ctx, v160.0);
                                                let v260 = C::u64_eq(ctx, v165, v259);
                                                if v260 == true {
                                                    let v168 = C::imm64(ctx, 0x1);
                                                    let v212 = constructor_iconst(ctx, v49, v168);
                                                    let v258 = C::subsume(ctx, v212);
                                                    // Rule at src/opts/icmp.isle line 73.
                                                    returns.push(v258);
                                                }
                                            }
                                        }
                                    }
                                    if v149.0 == v149.1 {
                                        let v168 = C::imm64(ctx, 0x1);
                                        let v212 = constructor_iconst(ctx, v49, v168);
                                        // Rule at src/opts/icmp.isle line 12.
                                        returns.push(v212);
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                    let v149 = C::unpack_value_array_2(ctx, v147);
                    let v152 = C::inst_data_etor(ctx, v149.0);
                    let mut v152 = v152;
                    while let Some(v153) = v152.next(ctx) {
                        if let &InstructionData::UnaryImm {
                            opcode: ref v338,
                            imm: v339,
                        } = &v153.1
                        {
                            if let &Opcode::Iconst = v338 {
                                let v159 = C::inst_data_etor(ctx, v149.1);
                                let mut v159 = v159;
                                while let Some(v160) = v159.next(ctx) {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref v163,
                                        imm: v164,
                                    } = &v160.1
                                    {
                                        if let &Opcode::Iconst = v163 {
                                            if v153.0 == v160.0 {
                                                let v340 =
                                                    C::imm64_icmp(ctx, v153.0, v148, v339, v164);
                                                let v341 = constructor_iconst(ctx, v2.0, v340);
                                                let v342 = C::subsume(ctx, v341);
                                                // Rule at src/opts/cprop.isle line 79.
                                                returns.push(v342);
                                            }
                                        }
                                    }
                                }
                                let v350 = &C::intcc_reverse(ctx, v148);
                                let v351 = constructor_icmp(ctx, v2.0, v350, v149.1, v149.0);
                                // Rule at src/opts/cprop.isle line 113.
                                returns.push(v351);
                            }
                        }
                    }
                }
            }
            &InstructionData::Ternary {
                opcode: ref v170,
                args: ref v171,
            } => {
                match v170 {
                    &Opcode::Select => {
                        let v172 = C::unpack_value_array_3(ctx, v171);
                        let v176 = C::inst_data_etor(ctx, v172.0);
                        let mut v176 = v176;
                        while let Some(v177) = v176.next(ctx) {
                            match &v177.1 {
                                &InstructionData::FloatCompare {
                                    opcode: ref v194,
                                    args: ref v195,
                                    cond: ref v196,
                                } => {
                                    if let &Opcode::Fcmp = v194 {
                                        match v196 {
                                            &FloatCC::GreaterThan => {
                                                let v197 = C::unpack_value_array_2(ctx, v195);
                                                if v172.1 == v197.0 {
                                                    if v172.2 == v197.1 {
                                                        let v201 = constructor_fmax_pseudo(
                                                            ctx, v2.0, v197.0, v197.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 392.
                                                        returns.push(v201);
                                                    }
                                                }
                                            }
                                            &FloatCC::LessThan => {
                                                let v197 = C::unpack_value_array_2(ctx, v195);
                                                if v172.1 == v197.0 {
                                                    if v172.2 == v197.1 {
                                                        let v200 = constructor_fmin_pseudo(
                                                            ctx, v2.0, v197.0, v197.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 389.
                                                        returns.push(v200);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v180,
                                    args: ref v181,
                                    cond: ref v182,
                                } => {
                                    if let &Opcode::Icmp = v180 {
                                        match v182 {
                                            &IntCC::SignedGreaterThan => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v186 = constructor_smax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 343.
                                                        returns.push(v186);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v188 = constructor_smin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 357.
                                                        returns.push(v188);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedGreaterThanOrEqual => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v186 = constructor_smax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 344.
                                                        returns.push(v186);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v188 = constructor_smin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 358.
                                                        returns.push(v188);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThan => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v188 = constructor_smin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 347.
                                                        returns.push(v188);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v186 = constructor_smax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 353.
                                                        returns.push(v186);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThanOrEqual => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v188 = constructor_smin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 348.
                                                        returns.push(v188);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v186 = constructor_smax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 354.
                                                        returns.push(v186);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThan => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v187 = constructor_umax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 345.
                                                        returns.push(v187);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v189 = constructor_umin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 359.
                                                        returns.push(v189);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThanOrEqual => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v187 = constructor_umax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 346.
                                                        returns.push(v187);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v189 = constructor_umin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 360.
                                                        returns.push(v189);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThan => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v189 = constructor_umin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 349.
                                                        returns.push(v189);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v187 = constructor_umax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 355.
                                                        returns.push(v187);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThanOrEqual => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v189 = constructor_umin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 350.
                                                        returns.push(v189);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v187 = constructor_umax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 356.
                                                        returns.push(v187);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v202,
                                    arg: v203,
                                } => {
                                    if let &Opcode::Uextend = v202 {
                                        let v227 = C::inst_data_etor(ctx, v203);
                                        let mut v227 = v227;
                                        while let Some(v228) = v227.next(ctx) {
                                            if let &InstructionData::IntCompare {
                                                opcode: ref v231,
                                                args: ref v232,
                                                cond: ref v233,
                                            } = &v228.1
                                            {
                                                if let &Opcode::Icmp = v231 {
                                                    let v237 = constructor_select(
                                                        ctx, v2.0, v203, v172.1, v172.2,
                                                    );
                                                    // Rule at src/opts/icmp.isle line 29.
                                                    returns.push(v237);
                                                    // Rule at src/opts/icmp.isle line 32.
                                                    returns.push(v237);
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v382,
                                    imm: v383,
                                } => {
                                    if let &Opcode::Iconst = v382 {
                                        let v384 = C::u64_from_imm64(ctx, v383);
                                        if v384 == 0x0 {
                                            // Rule at src/opts/cprop.isle line 169.
                                            returns.push(v172.2);
                                        }
                                        let v385 = C::u64_is_zero(ctx, v384);
                                        if v385 == false {
                                            // Rule at src/opts/cprop.isle line 166.
                                            returns.push(v172.1);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Bitselect => {
                        let v190 = C::multi_lane(ctx, v2.0);
                        if let Some(v191) = v190 {
                            let v172 = C::unpack_value_array_3(ctx, v171);
                            let v176 = C::inst_data_etor(ctx, v172.0);
                            let mut v176 = v176;
                            while let Some(v177) = v176.next(ctx) {
                                if let &InstructionData::IntCompare {
                                    opcode: ref v180,
                                    args: ref v181,
                                    cond: ref v182,
                                } = &v177.1
                                {
                                    if let &Opcode::Icmp = v180 {
                                        match v182 {
                                            &IntCC::SignedGreaterThan => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v186 = constructor_smax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 363.
                                                        returns.push(v186);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v188 = constructor_smin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 377.
                                                        returns.push(v188);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedGreaterThanOrEqual => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v186 = constructor_smax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 364.
                                                        returns.push(v186);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v188 = constructor_smin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 378.
                                                        returns.push(v188);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThan => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v188 = constructor_smin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 367.
                                                        returns.push(v188);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v186 = constructor_smax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 373.
                                                        returns.push(v186);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThanOrEqual => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v188 = constructor_smin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 368.
                                                        returns.push(v188);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v186 = constructor_smax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 374.
                                                        returns.push(v186);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThan => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v187 = constructor_umax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 365.
                                                        returns.push(v187);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v189 = constructor_umin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 379.
                                                        returns.push(v189);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThanOrEqual => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v187 = constructor_umax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 366.
                                                        returns.push(v187);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v189 = constructor_umin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 380.
                                                        returns.push(v189);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThan => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v189 = constructor_umin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 369.
                                                        returns.push(v189);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v187 = constructor_umax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 375.
                                                        returns.push(v187);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThanOrEqual => {
                                                let v183 = C::unpack_value_array_2(ctx, v181);
                                                if v172.1 == v183.0 {
                                                    if v172.2 == v183.1 {
                                                        let v189 = constructor_umin(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 370.
                                                        returns.push(v189);
                                                    }
                                                }
                                                if v172.1 == v183.1 {
                                                    if v172.2 == v183.0 {
                                                        let v187 = constructor_umax(
                                                            ctx, v2.0, v183.0, v183.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 376.
                                                        returns.push(v187);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Fma => {
                        let v172 = C::unpack_value_array_3(ctx, v171);
                        let v176 = C::inst_data_etor(ctx, v172.0);
                        let mut v176 = v176;
                        while let Some(v177) = v176.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v202,
                                arg: v203,
                            } = &v177.1
                            {
                                if let &Opcode::Fneg = v202 {
                                    if v2.0 == v177.0 {
                                        let v204 = C::inst_data_etor(ctx, v172.1);
                                        let mut v204 = v204;
                                        while let Some(v205) = v204.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v208,
                                                arg: v209,
                                            } = &v205.1
                                            {
                                                if let &Opcode::Fneg = v208 {
                                                    if v2.0 == v205.0 {
                                                        let v210 = constructor_fma(
                                                            ctx, v2.0, v203, v209, v172.2,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 405.
                                                        returns.push(v210);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::Unary {
                opcode: ref v5,
                arg: v6,
            } => {
                match v5 {
                    &Opcode::Ineg => {
                        let v7 = C::inst_data_etor(ctx, v6);
                        let mut v7 = v7;
                        while let Some(v8) = v7.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v11,
                                arg: v12,
                            } = &v8.1
                            {
                                if let &Opcode::Ineg = v11 {
                                    if v2.0 == v8.0 {
                                        let v37 = C::subsume(ctx, v12);
                                        // Rule at src/opts/algebraic.isle line 36.
                                        returns.push(v37);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Iabs => {
                        let v7 = C::inst_data_etor(ctx, v6);
                        let mut v7 = v7;
                        while let Some(v8) = v7.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v11,
                                arg: v12,
                            } = &v8.1
                            {
                                match v11 {
                                    &Opcode::Ineg => {
                                        if v2.0 == v8.0 {
                                            let v44 = constructor_iabs(ctx, v2.0, v12);
                                            // Rule at src/opts/algebraic.isle line 43.
                                            returns.push(v44);
                                        }
                                    }
                                    &Opcode::Iabs => {
                                        if v2.0 == v8.0 {
                                            let v45 = C::subsume(ctx, v6);
                                            // Rule at src/opts/algebraic.isle line 47.
                                            returns.push(v45);
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                    &Opcode::Bnot => {
                        let v7 = C::inst_data_etor(ctx, v6);
                        let mut v7 = v7;
                        while let Some(v8) = v7.next(ctx) {
                            match &v8.1 {
                                &InstructionData::Binary {
                                    opcode: ref v61,
                                    args: ref v62,
                                } => {
                                    match v61 {
                                        &Opcode::Band => {
                                            let v63 = C::unpack_value_array_2(ctx, v62);
                                            let v66 = constructor_bnot(ctx, v2.0, v63.0);
                                            let v67 = constructor_bnot(ctx, v2.0, v63.1);
                                            let v69 = constructor_bor(ctx, v2.0, v66, v67);
                                            // Rule at src/opts/algebraic.isle line 170.
                                            returns.push(v69);
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v8.0 {
                                                let v63 = C::unpack_value_array_2(ctx, v62);
                                                let v66 = constructor_bnot(ctx, v2.0, v63.0);
                                                let v67 = constructor_bnot(ctx, v2.0, v63.1);
                                                let v68 = constructor_band(ctx, v2.0, v66, v67);
                                                // Rule at src/opts/algebraic.isle line 167.
                                                returns.push(v68);
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v11,
                                    arg: v12,
                                } => {
                                    if let &Opcode::Bnot = v11 {
                                        if v2.0 == v8.0 {
                                            let v37 = C::subsume(ctx, v12);
                                            // Rule at src/opts/algebraic.isle line 163.
                                            returns.push(v37);
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v313,
                                    imm: v314,
                                } => {
                                    if let &Opcode::Iconst = v313 {
                                        let v46 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v47) = v46 {
                                            if v8.0 == v47 {
                                                let v315 = C::u64_from_imm64(ctx, v314);
                                                let v316 = C::u64_not(ctx, v315);
                                                let v317 = C::imm64_masked(ctx, v47, v316);
                                                let v318 = constructor_iconst(ctx, v47, v317);
                                                let v319 = C::subsume(ctx, v318);
                                                // Rule at src/opts/cprop.isle line 53.
                                                returns.push(v319);
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v138 = C::remat(ctx, arg0);
                        // Rule at src/opts/algebraic.isle line 316.
                        returns.push(v138);
                    }
                    &Opcode::Fneg => {
                        let v7 = C::inst_data_etor(ctx, v6);
                        let mut v7 = v7;
                        while let Some(v8) = v7.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v11,
                                arg: v12,
                            } = &v8.1
                            {
                                if let &Opcode::Fneg = v11 {
                                    if v2.0 == v8.0 {
                                        let v37 = C::subsume(ctx, v12);
                                        // Rule at src/opts/algebraic.isle line 401.
                                        returns.push(v37);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Uextend => {
                        let v7 = C::inst_data_etor(ctx, v6);
                        let mut v7 = v7;
                        while let Some(v8) = v7.next(ctx) {
                            match &v8.1 {
                                &InstructionData::Unary {
                                    opcode: ref v11,
                                    arg: v12,
                                } => {
                                    if let &Opcode::Uextend = v11 {
                                        let v13 = constructor_uextend(ctx, v2.0, v12);
                                        // Rule at src/opts/algebraic.isle line 10.
                                        returns.push(v13);
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v313,
                                    imm: v314,
                                } => {
                                    if let &Opcode::Iconst = v313 {
                                        let v46 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v47) = v46 {
                                            let v329 = C::u64_uextend_imm64(ctx, v8.0, v314);
                                            let v330 = C::imm64(ctx, v329);
                                            let v331 = constructor_iconst(ctx, v47, v330);
                                            let v332 = C::subsume(ctx, v331);
                                            // Rule at src/opts/cprop.isle line 73.
                                            returns.push(v332);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Sextend => {
                        let v7 = C::inst_data_etor(ctx, v6);
                        let mut v7 = v7;
                        while let Some(v8) = v7.next(ctx) {
                            match &v8.1 {
                                &InstructionData::Unary {
                                    opcode: ref v11,
                                    arg: v12,
                                } => {
                                    if let &Opcode::Sextend = v11 {
                                        let v14 = constructor_sextend(ctx, v2.0, v12);
                                        // Rule at src/opts/algebraic.isle line 12.
                                        returns.push(v14);
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v313,
                                    imm: v314,
                                } => {
                                    if let &Opcode::Iconst = v313 {
                                        let v46 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v47) = v46 {
                                            let v333 = C::i64_sextend_imm64(ctx, v8.0, v314);
                                            let v334 = C::i64_as_u64(ctx, v333);
                                            let v335 = C::imm64_masked(ctx, v47, v334);
                                            let v336 = constructor_iconst(ctx, v47, v335);
                                            let v337 = C::subsume(ctx, v336);
                                            // Rule at src/opts/cprop.isle line 76.
                                            returns.push(v337);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::UnaryIeee32 {
                opcode: ref v141,
                imm: v142,
            } => {
                if let &Opcode::F32const = v141 {
                    let v138 = C::remat(ctx, arg0);
                    // Rule at src/opts/algebraic.isle line 320.
                    returns.push(v138);
                }
            }
            &InstructionData::UnaryIeee64 {
                opcode: ref v143,
                imm: v144,
            } => {
                if let &Opcode::F64const = v143 {
                    let v138 = C::remat(ctx, arg0);
                    // Rule at src/opts/algebraic.isle line 322.
                    returns.push(v138);
                }
            }
            &InstructionData::UnaryImm {
                opcode: ref v139,
                imm: v140,
            } => {
                if let &Opcode::Iconst = v139 {
                    let v138 = C::remat(ctx, arg0);
                    // Rule at src/opts/algebraic.isle line 318.
                    returns.push(v138);
                }
            }
            _ => {}
        }
    }
    return ContextIterWrapper::from(returns.into_iter());
}

// Generated as internal constructor for term intcc_comparable.
pub fn constructor_intcc_comparable<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: &IntCC,
) -> Option<bool> {
    let v2 = constructor_intcc_class(ctx, arg0);
    let v3 = constructor_intcc_class(ctx, arg1);
    let v4 = C::u64_and(ctx, v2, v3);
    let v5 = C::u64_is_zero(ctx, v4);
    if v5 == false {
        let v7 = C::u64_eq(ctx, 0x2, v4);
        // Rule at src/opts/icmp.isle line 137.
        return Some(v7);
    }
    None
}

// Generated as internal constructor for term decompose_intcc.
pub fn constructor_decompose_intcc<C: Context>(ctx: &mut C, arg0: &IntCC) -> u64 {
    match arg0 {
        &IntCC::Equal => {
            // Rule at src/opts/icmp.isle line 142.
            return 0x1;
        }
        &IntCC::NotEqual => {
            // Rule at src/opts/icmp.isle line 151.
            return 0x6;
        }
        &IntCC::SignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 148.
            return 0x4;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 150.
            return 0x5;
        }
        &IntCC::SignedLessThan => {
            // Rule at src/opts/icmp.isle line 144.
            return 0x2;
        }
        &IntCC::SignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 146.
            return 0x3;
        }
        &IntCC::UnsignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 147.
            return 0x4;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 149.
            return 0x5;
        }
        &IntCC::UnsignedLessThan => {
            // Rule at src/opts/icmp.isle line 143.
            return 0x2;
        }
        &IntCC::UnsignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 145.
            return 0x3;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "decompose_intcc", "src/opts/icmp.isle line 141"
    )
}

// Generated as internal constructor for term compose_icmp.
pub fn constructor_compose_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: u64,
    arg2: bool,
    arg3: Value,
    arg4: Value,
) -> Value {
    match arg1 {
        0x0 => {
            let v6 = C::imm64(ctx, 0x0);
            let v7 = constructor_iconst(ctx, arg0, v6);
            let v8 = C::subsume(ctx, v7);
            // Rule at src/opts/icmp.isle line 154.
            return v8;
        }
        0x1 => {
            let v10 = constructor_icmp(ctx, arg0, &IntCC::Equal, arg3, arg4);
            // Rule at src/opts/icmp.isle line 155.
            return v10;
        }
        0x2 => {
            match arg2 {
                true => {
                    let v14 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 157.
                    return v14;
                }
                false => {
                    let v12 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 156.
                    return v12;
                }
                _ => {}
            }
        }
        0x3 => {
            match arg2 {
                true => {
                    let v18 =
                        constructor_icmp(ctx, arg0, &IntCC::SignedLessThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 159.
                    return v18;
                }
                false => {
                    let v16 =
                        constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 158.
                    return v16;
                }
                _ => {}
            }
        }
        0x4 => {
            match arg2 {
                true => {
                    let v22 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 161.
                    return v22;
                }
                false => {
                    let v20 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 160.
                    return v20;
                }
                _ => {}
            }
        }
        0x5 => {
            match arg2 {
                true => {
                    let v26 =
                        constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 163.
                    return v26;
                }
                false => {
                    let v24 =
                        constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 162.
                    return v24;
                }
                _ => {}
            }
        }
        0x6 => {
            let v28 = constructor_icmp(ctx, arg0, &IntCC::NotEqual, arg3, arg4);
            // Rule at src/opts/icmp.isle line 164.
            return v28;
        }
        0x7 => {
            let v30 = C::imm64(ctx, 0x1);
            let v31 = constructor_iconst(ctx, arg0, v30);
            let v32 = C::subsume(ctx, v31);
            // Rule at src/opts/icmp.isle line 165.
            return v32;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "compose_icmp", "src/opts/icmp.isle line 153"
    )
}

// Generated as internal constructor for term intcc_class.
pub fn constructor_intcc_class<C: Context>(ctx: &mut C, arg0: &IntCC) -> u64 {
    match arg0 {
        &IntCC::Equal => {
            // Rule at src/opts/icmp.isle line 176.
            return 0x3;
        }
        &IntCC::NotEqual => {
            // Rule at src/opts/icmp.isle line 177.
            return 0x3;
        }
        &IntCC::SignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 174.
            return 0x2;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 175.
            return 0x2;
        }
        &IntCC::SignedLessThan => {
            // Rule at src/opts/icmp.isle line 172.
            return 0x2;
        }
        &IntCC::SignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 173.
            return 0x2;
        }
        &IntCC::UnsignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 170.
            return 0x1;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 171.
            return 0x1;
        }
        &IntCC::UnsignedLessThan => {
            // Rule at src/opts/icmp.isle line 168.
            return 0x1;
        }
        &IntCC::UnsignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 169.
            return 0x1;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "intcc_class", "src/opts/icmp.isle line 167"
    )
}

// Generated as internal constructor for term func_addr.
pub fn constructor_func_addr<C: Context>(ctx: &mut C, arg0: Type, arg1: FuncRef) -> Value {
    let v3 = InstructionData::FuncAddr {
        opcode: Opcode::FuncAddr,
        func_ref: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 360.
    return v4;
}

// Generated as internal constructor for term splat.
pub fn constructor_splat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Splat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 369.
    return v4;
}

// Generated as internal constructor for term swizzle.
pub fn constructor_swizzle<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Swizzle,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 378.
    return v6;
}

// Generated as internal constructor for term x86_pshufb.
pub fn constructor_x86_pshufb<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pshufb,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 387.
    return v6;
}

// Generated as internal constructor for term insertlane.
pub fn constructor_insertlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Uimm8,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::TernaryImm8 {
        opcode: Opcode::Insertlane,
        args: v5.clone(),
        imm: arg3,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 396.
    return v7;
}

// Generated as internal constructor for term extractlane.
pub fn constructor_extractlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let v4 = InstructionData::BinaryImm8 {
        opcode: Opcode::Extractlane,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 405.
    return v5;
}

// Generated as internal constructor for term smin.
pub fn constructor_smin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 414.
    return v6;
}

// Generated as internal constructor for term umin.
pub fn constructor_umin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 423.
    return v6;
}

// Generated as internal constructor for term smax.
pub fn constructor_smax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 432.
    return v6;
}

// Generated as internal constructor for term umax.
pub fn constructor_umax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 441.
    return v6;
}

// Generated as internal constructor for term avg_round.
pub fn constructor_avg_round<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::AvgRound,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 450.
    return v6;
}

// Generated as internal constructor for term uadd_sat.
pub fn constructor_uadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::UaddSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 459.
    return v6;
}

// Generated as internal constructor for term sadd_sat.
pub fn constructor_sadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SaddSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 468.
    return v6;
}

// Generated as internal constructor for term usub_sat.
pub fn constructor_usub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::UsubSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 477.
    return v6;
}

// Generated as internal constructor for term ssub_sat.
pub fn constructor_ssub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SsubSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 486.
    return v6;
}

// Generated as internal constructor for term load.
pub fn constructor_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Load,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 495.
    return v6;
}

// Generated as internal constructor for term uload8.
pub fn constructor_uload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 504.
    return v6;
}

// Generated as internal constructor for term sload8.
pub fn constructor_sload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 513.
    return v6;
}

// Generated as internal constructor for term uload16.
pub fn constructor_uload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload16,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 522.
    return v6;
}

// Generated as internal constructor for term sload16.
pub fn constructor_sload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload16,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 531.
    return v6;
}

// Generated as internal constructor for term uload32.
pub fn constructor_uload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload32,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 540.
    return v6;
}

// Generated as internal constructor for term sload32.
pub fn constructor_sload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload32,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 549.
    return v6;
}

// Generated as internal constructor for term uload8x8.
pub fn constructor_uload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload8x8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 558.
    return v6;
}

// Generated as internal constructor for term sload8x8.
pub fn constructor_sload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload8x8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 567.
    return v6;
}

// Generated as internal constructor for term uload16x4.
pub fn constructor_uload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload16x4,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 576.
    return v6;
}

// Generated as internal constructor for term sload16x4.
pub fn constructor_sload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload16x4,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 585.
    return v6;
}

// Generated as internal constructor for term uload32x2.
pub fn constructor_uload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload32x2,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 594.
    return v6;
}

// Generated as internal constructor for term sload32x2.
pub fn constructor_sload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload32x2,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 603.
    return v6;
}

// Generated as internal constructor for term stack_load.
pub fn constructor_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let v4 = InstructionData::StackLoad {
        opcode: Opcode::StackLoad,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 612.
    return v5;
}

// Generated as internal constructor for term stack_addr.
pub fn constructor_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let v4 = InstructionData::StackLoad {
        opcode: Opcode::StackAddr,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 621.
    return v5;
}

// Generated as internal constructor for term dynamic_stack_load.
pub fn constructor_dynamic_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let v3 = InstructionData::DynamicStackLoad {
        opcode: Opcode::DynamicStackLoad,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 630.
    return v4;
}

// Generated as internal constructor for term dynamic_stack_addr.
pub fn constructor_dynamic_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let v3 = InstructionData::DynamicStackLoad {
        opcode: Opcode::DynamicStackAddr,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 639.
    return v4;
}

// Generated as internal constructor for term global_value.
pub fn constructor_global_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::GlobalValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 648.
    return v4;
}

// Generated as internal constructor for term symbol_value.
pub fn constructor_symbol_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::SymbolValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 657.
    return v4;
}

// Generated as internal constructor for term tls_value.
pub fn constructor_tls_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::TlsValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 666.
    return v4;
}

// Generated as internal constructor for term get_pinned_reg.
pub fn constructor_get_pinned_reg<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetPinnedReg,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 675.
    return v3;
}

// Generated as internal constructor for term get_frame_pointer.
pub fn constructor_get_frame_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetFramePointer,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 684.
    return v3;
}

// Generated as internal constructor for term get_stack_pointer.
pub fn constructor_get_stack_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetStackPointer,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 693.
    return v3;
}

// Generated as internal constructor for term get_return_address.
pub fn constructor_get_return_address<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetReturnAddress,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 702.
    return v3;
}

// Generated as internal constructor for term table_addr.
pub fn constructor_table_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Table,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::TableAddr {
        opcode: Opcode::TableAddr,
        arg: arg2,
        table: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 711.
    return v6;
}

// Generated as internal constructor for term iconst.
pub fn constructor_iconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Imm64) -> Value {
    let v3 = InstructionData::UnaryImm {
        opcode: Opcode::Iconst,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 720.
    return v4;
}

// Generated as internal constructor for term f32const.
pub fn constructor_f32const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee32) -> Value {
    let v3 = InstructionData::UnaryIeee32 {
        opcode: Opcode::F32const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 729.
    return v4;
}

// Generated as internal constructor for term f64const.
pub fn constructor_f64const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee64) -> Value {
    let v3 = InstructionData::UnaryIeee64 {
        opcode: Opcode::F64const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 738.
    return v4;
}

// Generated as internal constructor for term vconst.
pub fn constructor_vconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Constant) -> Value {
    let v3 = InstructionData::UnaryConst {
        opcode: Opcode::Vconst,
        constant_handle: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 747.
    return v4;
}

// Generated as internal constructor for term shuffle.
pub fn constructor_shuffle<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Immediate,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::Shuffle {
        opcode: Opcode::Shuffle,
        args: v5.clone(),
        imm: arg3,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 756.
    return v7;
}

// Generated as internal constructor for term null.
pub fn constructor_null<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::Null,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 765.
    return v3;
}

// Generated as internal constructor for term select.
pub fn constructor_select<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Select,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 774.
    return v7;
}

// Generated as internal constructor for term select_spectre_guard.
pub fn constructor_select_spectre_guard<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::SelectSpectreGuard,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 783.
    return v7;
}

// Generated as internal constructor for term bitselect.
pub fn constructor_bitselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Bitselect,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 792.
    return v7;
}

// Generated as internal constructor for term x86_blendv.
pub fn constructor_x86_blendv<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::X86Blendv,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 801.
    return v7;
}

// Generated as internal constructor for term vany_true.
pub fn constructor_vany_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VanyTrue,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 810.
    return v4;
}

// Generated as internal constructor for term vall_true.
pub fn constructor_vall_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VallTrue,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 819.
    return v4;
}

// Generated as internal constructor for term vhigh_bits.
pub fn constructor_vhigh_bits<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VhighBits,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 828.
    return v4;
}

// Generated as internal constructor for term icmp.
pub fn constructor_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::IntCompare {
        opcode: Opcode::Icmp,
        args: v5.clone(),
        cond: arg1.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 837.
    return v7;
}

// Generated as internal constructor for term icmp_imm.
pub fn constructor_icmp_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Imm64,
) -> Value {
    let v5 = InstructionData::IntCompareImm {
        opcode: Opcode::IcmpImm,
        arg: arg2,
        cond: arg1.clone(),
        imm: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 846.
    return v6;
}

// Generated as internal constructor for term iadd.
pub fn constructor_iadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Iadd,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 855.
    return v6;
}

// Generated as internal constructor for term isub.
pub fn constructor_isub<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Isub,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 864.
    return v6;
}

// Generated as internal constructor for term ineg.
pub fn constructor_ineg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ineg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 873.
    return v4;
}

// Generated as internal constructor for term iabs.
pub fn constructor_iabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Iabs,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 882.
    return v4;
}

// Generated as internal constructor for term imul.
pub fn constructor_imul<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Imul,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 891.
    return v6;
}

// Generated as internal constructor for term umulhi.
pub fn constructor_umulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umulhi,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 900.
    return v6;
}

// Generated as internal constructor for term smulhi.
pub fn constructor_smulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smulhi,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 909.
    return v6;
}

// Generated as internal constructor for term sqmul_round_sat.
pub fn constructor_sqmul_round_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SqmulRoundSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 918.
    return v6;
}

// Generated as internal constructor for term x86_pmulhrsw.
pub fn constructor_x86_pmulhrsw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pmulhrsw,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 927.
    return v6;
}

// Generated as internal constructor for term udiv.
pub fn constructor_udiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Udiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 936.
    return v6;
}

// Generated as internal constructor for term sdiv.
pub fn constructor_sdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Sdiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 945.
    return v6;
}

// Generated as internal constructor for term urem.
pub fn constructor_urem<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Urem,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 954.
    return v6;
}

// Generated as internal constructor for term srem.
pub fn constructor_srem<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Srem,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 963.
    return v6;
}

// Generated as internal constructor for term iadd_imm.
pub fn constructor_iadd_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IaddImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 972.
    return v5;
}

// Generated as internal constructor for term imul_imm.
pub fn constructor_imul_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::ImulImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 981.
    return v5;
}

// Generated as internal constructor for term udiv_imm.
pub fn constructor_udiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UdivImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 990.
    return v5;
}

// Generated as internal constructor for term sdiv_imm.
pub fn constructor_sdiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SdivImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 999.
    return v5;
}

// Generated as internal constructor for term urem_imm.
pub fn constructor_urem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UremImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1008.
    return v5;
}

// Generated as internal constructor for term srem_imm.
pub fn constructor_srem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SremImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1017.
    return v5;
}

// Generated as internal constructor for term irsub_imm.
pub fn constructor_irsub_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IrsubImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1026.
    return v5;
}

// Generated as internal constructor for term iadd_cin.
pub fn constructor_iadd_cin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::IaddCin,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1035.
    return v7;
}

// Generated as internal constructor for term uadd_overflow_trap.
pub fn constructor_uadd_overflow_trap<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: &TrapCode,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::IntAddTrap {
        opcode: Opcode::UaddOverflowTrap,
        args: v5.clone(),
        code: arg3.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1044.
    return v7;
}

// Generated as internal constructor for term isub_bin.
pub fn constructor_isub_bin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::IsubBin,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1053.
    return v7;
}

// Generated as internal constructor for term band.
pub fn constructor_band<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Band,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1062.
    return v6;
}

// Generated as internal constructor for term bor.
pub fn constructor_bor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Bor,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1071.
    return v6;
}

// Generated as internal constructor for term bxor.
pub fn constructor_bxor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Bxor,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1080.
    return v6;
}

// Generated as internal constructor for term bnot.
pub fn constructor_bnot<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bnot,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1089.
    return v4;
}

// Generated as internal constructor for term band_not.
pub fn constructor_band_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BandNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1098.
    return v6;
}

// Generated as internal constructor for term bor_not.
pub fn constructor_bor_not<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BorNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1107.
    return v6;
}

// Generated as internal constructor for term bxor_not.
pub fn constructor_bxor_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BxorNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1116.
    return v6;
}

// Generated as internal constructor for term band_imm.
pub fn constructor_band_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BandImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1125.
    return v5;
}

// Generated as internal constructor for term bor_imm.
pub fn constructor_bor_imm<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Imm64) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BorImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1134.
    return v5;
}

// Generated as internal constructor for term bxor_imm.
pub fn constructor_bxor_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BxorImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1143.
    return v5;
}

// Generated as internal constructor for term rotl.
pub fn constructor_rotl<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Rotl,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1152.
    return v6;
}

// Generated as internal constructor for term rotr.
pub fn constructor_rotr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Rotr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1161.
    return v6;
}

// Generated as internal constructor for term rotl_imm.
pub fn constructor_rotl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::RotlImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1170.
    return v5;
}

// Generated as internal constructor for term rotr_imm.
pub fn constructor_rotr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::RotrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1179.
    return v5;
}

// Generated as internal constructor for term ishl.
pub fn constructor_ishl<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Ishl,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1188.
    return v6;
}

// Generated as internal constructor for term ushr.
pub fn constructor_ushr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Ushr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1197.
    return v6;
}

// Generated as internal constructor for term sshr.
pub fn constructor_sshr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Sshr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1206.
    return v6;
}

// Generated as internal constructor for term ishl_imm.
pub fn constructor_ishl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IshlImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1215.
    return v5;
}

// Generated as internal constructor for term ushr_imm.
pub fn constructor_ushr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UshrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1224.
    return v5;
}

// Generated as internal constructor for term sshr_imm.
pub fn constructor_sshr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SshrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1233.
    return v5;
}

// Generated as internal constructor for term bitrev.
pub fn constructor_bitrev<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bitrev,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1242.
    return v4;
}

// Generated as internal constructor for term clz.
pub fn constructor_clz<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Clz,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1251.
    return v4;
}

// Generated as internal constructor for term cls.
pub fn constructor_cls<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Cls,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1260.
    return v4;
}

// Generated as internal constructor for term ctz.
pub fn constructor_ctz<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ctz,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1269.
    return v4;
}

// Generated as internal constructor for term bswap.
pub fn constructor_bswap<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bswap,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1278.
    return v4;
}

// Generated as internal constructor for term popcnt.
pub fn constructor_popcnt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Popcnt,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1287.
    return v4;
}

// Generated as internal constructor for term fcmp.
pub fn constructor_fcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FloatCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::FloatCompare {
        opcode: Opcode::Fcmp,
        args: v5.clone(),
        cond: arg1.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1296.
    return v7;
}

// Generated as internal constructor for term fadd.
pub fn constructor_fadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fadd,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1305.
    return v6;
}

// Generated as internal constructor for term fsub.
pub fn constructor_fsub<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fsub,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1314.
    return v6;
}

// Generated as internal constructor for term fmul.
pub fn constructor_fmul<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmul,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1323.
    return v6;
}

// Generated as internal constructor for term fdiv.
pub fn constructor_fdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fdiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1332.
    return v6;
}

// Generated as internal constructor for term sqrt.
pub fn constructor_sqrt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Sqrt,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1341.
    return v4;
}

// Generated as internal constructor for term fma.
pub fn constructor_fma<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Fma,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1350.
    return v7;
}

// Generated as internal constructor for term fneg.
pub fn constructor_fneg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fneg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1359.
    return v4;
}

// Generated as internal constructor for term fabs.
pub fn constructor_fabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fabs,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1368.
    return v4;
}

// Generated as internal constructor for term fcopysign.
pub fn constructor_fcopysign<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fcopysign,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1377.
    return v6;
}

// Generated as internal constructor for term fmin.
pub fn constructor_fmin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1386.
    return v6;
}

// Generated as internal constructor for term fmin_pseudo.
pub fn constructor_fmin_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::FminPseudo,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1395.
    return v6;
}

// Generated as internal constructor for term fmax.
pub fn constructor_fmax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1404.
    return v6;
}

// Generated as internal constructor for term fmax_pseudo.
pub fn constructor_fmax_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::FmaxPseudo,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1413.
    return v6;
}

// Generated as internal constructor for term ceil.
pub fn constructor_ceil<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ceil,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1422.
    return v4;
}

// Generated as internal constructor for term floor.
pub fn constructor_floor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Floor,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1431.
    return v4;
}

// Generated as internal constructor for term trunc.
pub fn constructor_trunc<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Trunc,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1440.
    return v4;
}

// Generated as internal constructor for term nearest.
pub fn constructor_nearest<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Nearest,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1449.
    return v4;
}

// Generated as internal constructor for term is_null.
pub fn constructor_is_null<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::IsNull,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1458.
    return v4;
}

// Generated as internal constructor for term is_invalid.
pub fn constructor_is_invalid<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::IsInvalid,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1467.
    return v4;
}

// Generated as internal constructor for term bitcast.
pub fn constructor_bitcast<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let v4 = InstructionData::LoadNoOffset {
        opcode: Opcode::Bitcast,
        arg: arg2,
        flags: arg1,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1476.
    return v5;
}

// Generated as internal constructor for term scalar_to_vector.
pub fn constructor_scalar_to_vector<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::ScalarToVector,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1485.
    return v4;
}

// Generated as internal constructor for term bmask.
pub fn constructor_bmask<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bmask,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1494.
    return v4;
}

// Generated as internal constructor for term ireduce.
pub fn constructor_ireduce<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ireduce,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1503.
    return v4;
}

// Generated as internal constructor for term snarrow.
pub fn constructor_snarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Snarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1512.
    return v6;
}

// Generated as internal constructor for term unarrow.
pub fn constructor_unarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Unarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1521.
    return v6;
}

// Generated as internal constructor for term uunarrow.
pub fn constructor_uunarrow<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Uunarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1530.
    return v6;
}

// Generated as internal constructor for term swiden_low.
pub fn constructor_swiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SwidenLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1539.
    return v4;
}

// Generated as internal constructor for term swiden_high.
pub fn constructor_swiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SwidenHigh,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1548.
    return v4;
}

// Generated as internal constructor for term uwiden_low.
pub fn constructor_uwiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::UwidenLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1557.
    return v4;
}

// Generated as internal constructor for term uwiden_high.
pub fn constructor_uwiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::UwidenHigh,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1566.
    return v4;
}

// Generated as internal constructor for term iadd_pairwise.
pub fn constructor_iadd_pairwise<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::IaddPairwise,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1575.
    return v6;
}

// Generated as internal constructor for term x86_pmaddubsw.
pub fn constructor_x86_pmaddubsw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pmaddubsw,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1584.
    return v6;
}

// Generated as internal constructor for term uextend.
pub fn constructor_uextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Uextend,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1593.
    return v4;
}

// Generated as internal constructor for term sextend.
pub fn constructor_sextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Sextend,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1602.
    return v4;
}

// Generated as internal constructor for term fpromote.
pub fn constructor_fpromote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fpromote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1611.
    return v4;
}

// Generated as internal constructor for term fdemote.
pub fn constructor_fdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fdemote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1620.
    return v4;
}

// Generated as internal constructor for term fvdemote.
pub fn constructor_fvdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fvdemote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1629.
    return v4;
}

// Generated as internal constructor for term fvpromote_low.
pub fn constructor_fvpromote_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FvpromoteLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1638.
    return v4;
}

// Generated as internal constructor for term fcvt_to_uint.
pub fn constructor_fcvt_to_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToUint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1647.
    return v4;
}

// Generated as internal constructor for term fcvt_to_sint.
pub fn constructor_fcvt_to_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1656.
    return v4;
}

// Generated as internal constructor for term fcvt_to_uint_sat.
pub fn constructor_fcvt_to_uint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToUintSat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1665.
    return v4;
}

// Generated as internal constructor for term fcvt_to_sint_sat.
pub fn constructor_fcvt_to_sint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToSintSat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1674.
    return v4;
}

// Generated as internal constructor for term x86_cvtt2dq.
pub fn constructor_x86_cvtt2dq<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::X86Cvtt2dq,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1683.
    return v4;
}

// Generated as internal constructor for term fcvt_from_uint.
pub fn constructor_fcvt_from_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtFromUint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1692.
    return v4;
}

// Generated as internal constructor for term fcvt_from_sint.
pub fn constructor_fcvt_from_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtFromSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1701.
    return v4;
}

// Generated as internal constructor for term fcvt_low_from_sint.
pub fn constructor_fcvt_low_from_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtLowFromSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1710.
    return v4;
}

// Generated as internal constructor for term iconcat.
pub fn constructor_iconcat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Iconcat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1719.
    return v6;
}

// Generated as internal constructor for term atomic_rmw.
pub fn constructor_atomic_rmw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: &AtomicRmwOp,
    arg3: Value,
    arg4: Value,
) -> Value {
    let v6 = &C::value_array_2_ctor(ctx, arg3, arg4);
    let v7 = InstructionData::AtomicRmw {
        opcode: Opcode::AtomicRmw,
        args: v6.clone(),
        flags: arg1,
        op: arg2.clone(),
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1728.
    return v8;
}

// Generated as internal constructor for term atomic_cas.
pub fn constructor_atomic_cas<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Value,
) -> Value {
    let v6 = &C::value_array_3_ctor(ctx, arg2, arg3, arg4);
    let v7 = InstructionData::AtomicCas {
        opcode: Opcode::AtomicCas,
        args: v6.clone(),
        flags: arg1,
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1737.
    return v8;
}

// Generated as internal constructor for term atomic_load.
pub fn constructor_atomic_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let v4 = InstructionData::LoadNoOffset {
        opcode: Opcode::AtomicLoad,
        arg: arg2,
        flags: arg1,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1746.
    return v5;
}

// Generated as internal constructor for term extract_vector.
pub fn constructor_extract_vector<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let v4 = InstructionData::BinaryImm8 {
        opcode: Opcode::ExtractVector,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/giorgiomartucci/rust_web/target/debug/build/cranelift-codegen-7a8331519c327458/out/clif_opt.isle line 1755.
    return v5;
}
